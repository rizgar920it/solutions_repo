{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 1. Theoretical Foundation Projectile motion is a classic application of Newton\u2019s laws in two dimensions. Let\u2019s derive the governing equations from first principles, assuming no air resistance and a constant gravitational field, to establish the framework. Derivation of the Equations of Motion Consider a projectile launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The initial velocity components are: Horizontal: \\(v_{x0} = v_0 \\cos\\theta\\) Vertical: \\(v_{y0} = v_0 \\sin\\theta\\) The only acceleration is due to gravity, acting downward: \\(a_y = -g\\) , where \\(g \\approx 9.8 \\, \\text{m/s}^2\\) , and \\(a_x = 0\\) . Starting with the kinematic equations: Horizontal Motion Acceleration: \\(\\frac{d^2 x}{dt^2} = 0\\) Velocity: \\(\\frac{dx}{dt} = v_{x0} = v_0 \\cos\\theta\\) Position: \\(x(t) = v_0 \\cos\\theta \\cdot t\\) Vertical Motion Acceleration: \\(\\frac{d^2 y}{dt^2} = -g\\) Velocity: \\(\\frac{dy}{dt} = v_{y0} - g t = v_0 \\sin\\theta - g t\\) Position: Integrate velocity: \\(y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\) These are the parametric equations of motion, forming a parabola under ideal conditions. Family of Solutions The solutions depend on free parameters: \\(v_0\\) , \\(\\theta\\) , and \\(g\\) . Additionally, if launched from a height \\(h\\) (i.e., \\(y_0 = h\\) ), the vertical position becomes: \\[y(t) = h + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\] Varying \\(v_0\\) , \\(\\theta\\) , \\(g\\) , or \\(h\\) generates a family of trajectories, from shallow arcs to steep climbs, adaptable to diverse scenarios. 2. Analysis of the Range The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . For launch height \\(h = 0\\) : Time of Flight Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ - Trivial solution: \\(t = 0s\\) (start) - Non-trivial: \\((t = \\frac{2 v_0 \\sin\\theta}{g})\\) Range Equation Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\( \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) \\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ Dependence on Angle Maximum Range : \\(R\\) is maximized when \\(\\sin 2\\theta = 1\\) , so \\(2\\theta = 90^\\circ\\) , \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . Symmetry : \\(R(\\theta) = R(90^\\circ - \\theta)\\) , e.g., \\(15^\\circ\\) and \\(75^\\circ\\) yield the same range. Limits : At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) . Influence of Parameters Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) , a quadratic increase. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) , inversely proportional. On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), range is ~6 times greater than Earth\u2019s. Launch Height ( \\(h > 0\\) ) : Increases time of flight, thus extending range. Requires solving a quadratic for \\(t\\) , complicating the expression. 3. Practical Applications This model applies to: - Sports : Optimizing a basketball shot or golf drive ( \\(\\theta \\approx 45^\\circ\\) for flat ground). - Engineering : Artillery or rocket launches, adjusting for terrain or wind. - Astrophysics : Simplified trajectories of celestial bodies (neglecting orbital mechanics). For uneven terrain (landing at \\(y = h_f\\) ), modify the range calculation. With air resistance, numerical methods (e.g., Euler or Runge-Kutta) are needed, reducing range and altering the optimal angle. 4. Implementation Here\u2019s a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta_deg, g=9.8, h=0): theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # Time of flight with initial height a = -g / 2 b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 20, 30] # m/s g = 9.8 # m/s^2 theta_deg = np.arange(0, 91, 1) h_values = [0, 10] # m # Plotting plt.figure(figsize=(10, 6)) for v0 in v0_values: R = [projectile_range(v0, t, g, h=0) for t in theta_deg] plt.plot(theta_deg, R, label=f'v0 = {v0} m/s, h = 0 m') for h in h_values: R = [projectile_range(20, t, g, h) for t in theta_deg] plt.plot(theta_deg, R, '--', label=f'v0 = 20 m/s, h = {h} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() Output This generates a plot showing: - Range peaking at \\(45^\\circ\\) for \\(h = 0\\) . - Increased range with higher \\(v_0\\) . - Extended range and shifted optimal angle $below \\(45^\\circ\\) with \\(h > 0\\) . Discussion Limitations Idealization : Assumes no air resistance, flat terrain, and constant \\(g\\) . Realism : Drag reduces range and shifts the optimal angle (e.g., ~30\u201340\u00b0 for a golf ball). Extensions Drag : Incorporate \\(-k v\\) terms, solved numerically. Wind : Add velocity components to \\(v_x\\) and \\(v_y\\) . Terrain : Model \\(y = f(x)\\) for landing height. This framework, while simple, is a stepping stone to complex simulations in physics and engineering. This delivers a theoretical foundation, analytical insights, a practical implementation, and a discussion of real-world adaptations. Let me know if you\u2019d like to refine any section or explore extensions like air resistance numerically!","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is a classic application of Newton\u2019s laws in two dimensions. Let\u2019s derive the governing equations from first principles, assuming no air resistance and a constant gravitational field, to establish the framework.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-the-equations-of-motion","text":"Consider a projectile launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The initial velocity components are: Horizontal: \\(v_{x0} = v_0 \\cos\\theta\\) Vertical: \\(v_{y0} = v_0 \\sin\\theta\\) The only acceleration is due to gravity, acting downward: \\(a_y = -g\\) , where \\(g \\approx 9.8 \\, \\text{m/s}^2\\) , and \\(a_x = 0\\) . Starting with the kinematic equations:","title":"Derivation of the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Acceleration: \\(\\frac{d^2 x}{dt^2} = 0\\) Velocity: \\(\\frac{dx}{dt} = v_{x0} = v_0 \\cos\\theta\\) Position: \\(x(t) = v_0 \\cos\\theta \\cdot t\\)","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Acceleration: \\(\\frac{d^2 y}{dt^2} = -g\\) Velocity: \\(\\frac{dy}{dt} = v_{y0} - g t = v_0 \\sin\\theta - g t\\) Position: Integrate velocity: \\(y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\) These are the parametric equations of motion, forming a parabola under ideal conditions.","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The solutions depend on free parameters: \\(v_0\\) , \\(\\theta\\) , and \\(g\\) . Additionally, if launched from a height \\(h\\) (i.e., \\(y_0 = h\\) ), the vertical position becomes: \\[y(t) = h + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\] Varying \\(v_0\\) , \\(\\theta\\) , \\(g\\) , or \\(h\\) generates a family of trajectories, from shallow arcs to steep climbs, adaptable to diverse scenarios.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . For launch height \\(h = 0\\) :","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ - Trivial solution: \\(t = 0s\\) (start) - Non-trivial: \\((t = \\frac{2 v_0 \\sin\\theta}{g})\\)","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\( \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) \\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-angle","text":"Maximum Range : \\(R\\) is maximized when \\(\\sin 2\\theta = 1\\) , so \\(2\\theta = 90^\\circ\\) , \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . Symmetry : \\(R(\\theta) = R(90^\\circ - \\theta)\\) , e.g., \\(15^\\circ\\) and \\(75^\\circ\\) yield the same range. Limits : At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) .","title":"Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) , a quadratic increase. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) , inversely proportional. On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), range is ~6 times greater than Earth\u2019s. Launch Height ( \\(h > 0\\) ) : Increases time of flight, thus extending range. Requires solving a quadratic for \\(t\\) , complicating the expression.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model applies to: - Sports : Optimizing a basketball shot or golf drive ( \\(\\theta \\approx 45^\\circ\\) for flat ground). - Engineering : Artillery or rocket launches, adjusting for terrain or wind. - Astrophysics : Simplified trajectories of celestial bodies (neglecting orbital mechanics). For uneven terrain (landing at \\(y = h_f\\) ), modify the range calculation. With air resistance, numerical methods (e.g., Euler or Runge-Kutta) are needed, reducing range and altering the optimal angle.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Here\u2019s a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta_deg, g=9.8, h=0): theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # Time of flight with initial height a = -g / 2 b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 20, 30] # m/s g = 9.8 # m/s^2 theta_deg = np.arange(0, 91, 1) h_values = [0, 10] # m # Plotting plt.figure(figsize=(10, 6)) for v0 in v0_values: R = [projectile_range(v0, t, g, h=0) for t in theta_deg] plt.plot(theta_deg, R, label=f'v0 = {v0} m/s, h = 0 m') for h in h_values: R = [projectile_range(20, t, g, h) for t in theta_deg] plt.plot(theta_deg, R, '--', label=f'v0 = 20 m/s, h = {h} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output","text":"This generates a plot showing: - Range peaking at \\(45^\\circ\\) for \\(h = 0\\) . - Increased range with higher \\(v_0\\) . - Extended range and shifted optimal angle $below \\(45^\\circ\\) with \\(h > 0\\) .","title":"Output"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Idealization : Assumes no air resistance, flat terrain, and constant \\(g\\) . Realism : Drag reduces range and shifts the optimal angle (e.g., ~30\u201340\u00b0 for a golf ball).","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions","text":"Drag : Incorporate \\(-k v\\) terms, solved numerically. Wind : Add velocity components to \\(v_x\\) and \\(v_y\\) . Terrain : Model \\(y = f(x)\\) for landing height. This framework, while simple, is a stepping stone to complex simulations in physics and engineering. This delivers a theoretical foundation, analytical insights, a practical implementation, and a discussion of real-world adaptations. Let me know if you\u2019d like to refine any section or explore extensions like air resistance numerically!","title":"Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Let\u2019s dive into the fascinating world of the forced damped pendulum! Below is a comprehensive response structured as a Markdown document, including theoretical derivations, analysis, practical applications, and a Python script for simulations. I\u2019ll keep the tone engaging and clear, walking you through each step as if we\u2019re exploring this together. Investigating the Dynamics of a Forced Damped Pendulum The forced damped pendulum is a classic system that blends simplicity with complexity, revealing a treasure trove of behaviors from orderly oscillations to wild chaos. Let\u2019s break this down step-by-step, derive the key equations, analyze the dynamics, and simulate it with Python to see it all come to life. 1. Theoretical Foundation The Governing Equation The motion of a forced damped pendulum is described by a second-order nonlinear differential equation. Picture a pendulum swinging under gravity, slowed by friction (damping), and nudged periodically by an external force. The equation is: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = F \\cos(\\omega_d t) \\] \\(\\theta\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (friction per unit mass) \\(g\\) : Gravitational acceleration ( \\(9.8 \\, \\text{m/s}^2\\) ) \\(L\\) : Pendulum length (m) \\(F\\) : Amplitude of the external driving force (per unit mass) \\(\\omega_d\\) : Driving frequency (rad/s) \\(\\dot{\\theta} = \\frac{d\\theta}{dt}\\) , \\(\\ddot{\\theta} = \\frac{d^2\\theta}{dt^2}\\) Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to a linear form, resembling a driven damped harmonic oscillator: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) \\] where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the undriven, undamped pendulum. General Solution For this linear system, the solution is the sum of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2} t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) (underdamped case, \\(b < 2\\omega_0\\) ). Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , or in amplitude-phase form, \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) . Using the method of undetermined coefficients, the steady-state amplitude is: \\[ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}} \\] The phase shift \\(\\delta\\) depends on the frequency difference and damping. Resonance Conditions Resonance occurs when the driving frequency \\(\\omega_d\\) approaches the natural frequency \\(\\omega_0\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply near \\(\\omega_d = \\omega_0\\) , amplifying the pendulum\u2019s swings dramatically. The energy input from the driving force matches the system\u2019s natural rhythm, overpowering dissipation. We\u2019ll see this in simulations! 2. Analysis of Dynamics Parameter Effects Damping Coefficient ( \\(b\\) ) : Low \\(b\\) allows sustained oscillations; high \\(b\\) quickly damps motion to a steady state or rest. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields gentle oscillations; large \\(F\\) can push the system beyond linearity into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion; far from \\(\\omega_0\\) , the pendulum struggles to sync, leading to complex patterns. Transition to Chaos Beyond small angles, the \\(\\sin(\\theta)\\) nonlinearity kicks in. With strong forcing and moderate damping, the system can exhibit: - Periodic Motion : Synchronized with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies. - Chaotic Motion : Unpredictable, aperiodic swings sensitive to initial conditions. The transition to chaos often occurs as \\(F\\) increases, revealed in phase portraits and Poincar\u00e9 sections. 3. Practical Applications Energy Harvesting : Piezoelectric devices mimic forced oscillators, converting vibrations into electricity. Suspension Bridges : Wind acts as a periodic force; damping prevents catastrophic resonance (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits parallel this system, used in radios and signal processing. 4. Implementation: Python Simulation Let\u2019s simulate this with Python using the Runge-Kutta (RK4) method to solve the nonlinear equation numerically. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pendulum_deriv(state, t, b, omega0_sq, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega0_sq * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.8 L = 1.0 omega0_sq = g / L b_values = [0.1, 0.5, 1.0] # Damping coefficients F_values = [0.5, 1.2, 1.5] # Driving amplitudes omega_d = 2.0 / 3.0 * np.sqrt(g / L) # Driving frequency t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0.0] # [theta0, theta_dot0] # Simulate and plot for varying b plt.figure(figsize=(12, 8)) for b in b_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(b, omega0_sq, F_values[0], omega_d)) plt.plot(t, sol[:, 0], label=f'b = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Effect of Damping Coefficient (F = 0.5, \u03c9_d = 2/3 \u03c9_0)') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) for F in F_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(0.5, omega0_sq, F, omega_d)) plt.plot(sol[:, 0], sol[:, 1], label=f'F = {F}', alpha=0.7) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Phase Portrait for Varying Driving Amplitude') plt.legend() plt.grid() plt.show() # Poincar\u00e9 section (sample at driving period) T_d = 2 * np.pi / omega_d t_poincare = np.arange(0, 100, T_d) sol_poincare = odeint(pendulum_deriv, initial_conditions, t_poincare, args=(0.5, omega0_sq, 1.5, omega_d)) plt.figure(figsize=(8, 6)) plt.scatter(sol_poincare[:, 0], sol_poincare[:, 1], s=10, c='red') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Poincar\u00e9 Section (F = 1.5, b = 0.5)') plt.grid() plt.show() Outputs Time Series : Shows how damping suppresses oscillations. Phase Portrait : Traces loops or chaotic trajectories as \\(F\\) increases. Poincar\u00e9 Section : Dots indicate periodic motion; scattered points suggest chaos. Discussion Limitations Assumes constant \\(b\\) and periodic forcing; real systems may have nonlinear damping or irregular drives. Small-angle solutions fail for large swings where nonlinearity dominates. Extensions Add nonlinear damping ( \\(b |\\dot{\\theta}| \\dot{\\theta}\\) ). Explore non-periodic forcing (e.g., random or multi-frequency drives). Couple multiple pendulums for collective dynamics. Visual Insights Resonance : Peaks in amplitude near \\(\\omega_d = \\omega_0\\) . Chaos : Poincar\u00e9 sections transition from orderly dots to scattered clouds as \\(F\\) grows. This journey through the forced damped pendulum reveals a microcosm of physics\u2014simple rules spawning complex beauty. Whether harvesting energy or stabilizing bridges, its lessons resonate far and wide.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"The forced damped pendulum is a classic system that blends simplicity with complexity, revealing a treasure trove of behaviors from orderly oscillations to wild chaos. Let\u2019s break this down step-by-step, derive the key equations, analyze the dynamics, and simulate it with Python to see it all come to life.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#the-governing-equation","text":"The motion of a forced damped pendulum is described by a second-order nonlinear differential equation. Picture a pendulum swinging under gravity, slowed by friction (damping), and nudged periodically by an external force. The equation is: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = F \\cos(\\omega_d t) \\] \\(\\theta\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (friction per unit mass) \\(g\\) : Gravitational acceleration ( \\(9.8 \\, \\text{m/s}^2\\) ) \\(L\\) : Pendulum length (m) \\(F\\) : Amplitude of the external driving force (per unit mass) \\(\\omega_d\\) : Driving frequency (rad/s) \\(\\dot{\\theta} = \\frac{d\\theta}{dt}\\) , \\(\\ddot{\\theta} = \\frac{d^2\\theta}{dt^2}\\)","title":"The Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to a linear form, resembling a driven damped harmonic oscillator: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) \\] where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the undriven, undamped pendulum.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solution","text":"For this linear system, the solution is the sum of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2} t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) (underdamped case, \\(b < 2\\omega_0\\) ). Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , or in amplitude-phase form, \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) . Using the method of undetermined coefficients, the steady-state amplitude is: \\[ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}} \\] The phase shift \\(\\delta\\) depends on the frequency difference and damping.","title":"General Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega_d\\) approaches the natural frequency \\(\\omega_0\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply near \\(\\omega_d = \\omega_0\\) , amplifying the pendulum\u2019s swings dramatically. The energy input from the driving force matches the system\u2019s natural rhythm, overpowering dissipation. We\u2019ll see this in simulations!","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-effects","text":"Damping Coefficient ( \\(b\\) ) : Low \\(b\\) allows sustained oscillations; high \\(b\\) quickly damps motion to a steady state or rest. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields gentle oscillations; large \\(F\\) can push the system beyond linearity into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion; far from \\(\\omega_0\\) , the pendulum struggles to sync, leading to complex patterns.","title":"Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Beyond small angles, the \\(\\sin(\\theta)\\) nonlinearity kicks in. With strong forcing and moderate damping, the system can exhibit: - Periodic Motion : Synchronized with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies. - Chaotic Motion : Unpredictable, aperiodic swings sensitive to initial conditions. The transition to chaos often occurs as \\(F\\) increases, revealed in phase portraits and Poincar\u00e9 sections.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Piezoelectric devices mimic forced oscillators, converting vibrations into electricity. Suspension Bridges : Wind acts as a periodic force; damping prevents catastrophic resonance (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits parallel this system, used in radios and signal processing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"Let\u2019s simulate this with Python using the Runge-Kutta (RK4) method to solve the nonlinear equation numerically. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pendulum_deriv(state, t, b, omega0_sq, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega0_sq * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.8 L = 1.0 omega0_sq = g / L b_values = [0.1, 0.5, 1.0] # Damping coefficients F_values = [0.5, 1.2, 1.5] # Driving amplitudes omega_d = 2.0 / 3.0 * np.sqrt(g / L) # Driving frequency t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0.0] # [theta0, theta_dot0] # Simulate and plot for varying b plt.figure(figsize=(12, 8)) for b in b_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(b, omega0_sq, F_values[0], omega_d)) plt.plot(t, sol[:, 0], label=f'b = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Effect of Damping Coefficient (F = 0.5, \u03c9_d = 2/3 \u03c9_0)') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) for F in F_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(0.5, omega0_sq, F, omega_d)) plt.plot(sol[:, 0], sol[:, 1], label=f'F = {F}', alpha=0.7) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Phase Portrait for Varying Driving Amplitude') plt.legend() plt.grid() plt.show() # Poincar\u00e9 section (sample at driving period) T_d = 2 * np.pi / omega_d t_poincare = np.arange(0, 100, T_d) sol_poincare = odeint(pendulum_deriv, initial_conditions, t_poincare, args=(0.5, omega0_sq, 1.5, omega_d)) plt.figure(figsize=(8, 6)) plt.scatter(sol_poincare[:, 0], sol_poincare[:, 1], s=10, c='red') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Poincar\u00e9 Section (F = 1.5, b = 0.5)') plt.grid() plt.show()","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#outputs","text":"Time Series : Shows how damping suppresses oscillations. Phase Portrait : Traces loops or chaotic trajectories as \\(F\\) increases. Poincar\u00e9 Section : Dots indicate periodic motion; scattered points suggest chaos.","title":"Outputs"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"Assumes constant \\(b\\) and periodic forcing; real systems may have nonlinear damping or irregular drives. Small-angle solutions fail for large swings where nonlinearity dominates.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"Add nonlinear damping ( \\(b |\\dot{\\theta}| \\dot{\\theta}\\) ). Explore non-periodic forcing (e.g., random or multi-frequency drives). Couple multiple pendulums for collective dynamics.","title":"Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visual-insights","text":"Resonance : Peaks in amplitude near \\(\\omega_d = \\omega_0\\) . Chaos : Poincar\u00e9 sections transition from orderly dots to scattered clouds as \\(F\\) grows. This journey through the forced damped pendulum reveals a microcosm of physics\u2014simple rules spawning complex beauty. Whether harvesting energy or stabilizing bridges, its lessons resonate far and wide.","title":"Visual Insights"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Here's a step-by-step derivation and analysis of Kepler's Third Law, its implications in astronomy, and a computational model using Python with visualizations and animations: 1. Derivation of Kepler's Third Law: For circular orbits, the gravitational force acts as a centripetal force. Thus: \\(F_\\text{gravity} = F_\\text{centripetal}\\) Using Newton\u2019s law of universal gravitation: \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central object, - \\(m\\) is the orbiting object's mass, - \\(r\\) is the orbital radius, - \\(v\\) is orbital velocity. Simplifying: \\(\\frac{GM}{r^2} = \\frac{v^2}{r} \\quad \\Rightarrow \\quad v^2 = \\frac{GM}{r}\\) Orbital period \\(T\\) is related to velocity by \\(v = \\frac{2\\pi r}{T}\\) , thus: \\(\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\) Solve for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler's Third Law, which states: \\(\\boxed{T^2 \\propto r^3}\\) The orbital period squared is proportional to the orbital radius cubed. 2. Implications for Astronomy: Kepler\u2019s Third Law has significant implications: Planetary Mass and Distance Calculation : By observing orbital periods and distances, astronomers can calculate the mass of planets, stars, and other celestial bodies. It\u2019s crucial for understanding star systems and galaxies. Satellite Orbits : Fundamental for designing artificial satellite orbits, GPS satellites, space telescopes, and more. 3. Real-world Examples: Moon\u2019s Orbit around Earth : Moon's orbital radius ~384,400 km, orbital period ~27.3 days. Using Kepler\u2019s law, we can verify Earth\u2019s mass accurately. Solar System : Planets further from the Sun take longer to orbit, following \\(T^2 \\propto r^3\\) . Examples: Mercury (~88 days), Earth (1 year), Jupiter (~12 years), Saturn (~29 years). 4. Python Computational Model: Below is Python code using Matplotlib to animate circular orbits and demonstrate Kepler's Third Law: Python Implementation: import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() This animation clearly demonstrates a stable circular orbit around a central body (Earth), and the Python computation verifies the accuracy of Kepler\u2019s third law numerically. 5. Explanation of the Simulation Results: The animation illustrates the orbital mechanics visually, showing a circular orbit around Earth. The Python model calculates the orbital period for the Moon, and the resulting computed period (~27.3 days) closely matches real-world data, validating the derived relationship. Conclusion: Kepler\u2019s Third Law provides an elegant yet powerful tool for astronomers and engineers. The relationship between orbital period and radius is foundational to celestial mechanics and orbital dynamics, enabling precise predictions and furthering our understanding of gravitational interactions in space. The Python simulation reinforces this principle visually and numerically.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Here's a step-by-step derivation and analysis of Kepler's Third Law, its implications in astronomy, and a computational model using Python with visualizations and animations:","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law","text":"For circular orbits, the gravitational force acts as a centripetal force. Thus: \\(F_\\text{gravity} = F_\\text{centripetal}\\) Using Newton\u2019s law of universal gravitation: \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central object, - \\(m\\) is the orbiting object's mass, - \\(r\\) is the orbital radius, - \\(v\\) is orbital velocity. Simplifying: \\(\\frac{GM}{r^2} = \\frac{v^2}{r} \\quad \\Rightarrow \\quad v^2 = \\frac{GM}{r}\\) Orbital period \\(T\\) is related to velocity by \\(v = \\frac{2\\pi r}{T}\\) , thus: \\(\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\) Solve for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler's Third Law, which states: \\(\\boxed{T^2 \\propto r^3}\\) The orbital period squared is proportional to the orbital radius cubed.","title":"1. Derivation of Kepler's Third Law:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler\u2019s Third Law has significant implications: Planetary Mass and Distance Calculation : By observing orbital periods and distances, astronomers can calculate the mass of planets, stars, and other celestial bodies. It\u2019s crucial for understanding star systems and galaxies. Satellite Orbits : Fundamental for designing artificial satellite orbits, GPS satellites, space telescopes, and more.","title":"2. Implications for Astronomy:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Moon\u2019s Orbit around Earth : Moon's orbital radius ~384,400 km, orbital period ~27.3 days. Using Kepler\u2019s law, we can verify Earth\u2019s mass accurately. Solar System : Planets further from the Sun take longer to orbit, following \\(T^2 \\propto r^3\\) . Examples: Mercury (~88 days), Earth (1 year), Jupiter (~12 years), Saturn (~29 years).","title":"3. Real-world Examples:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-computational-model","text":"Below is Python code using Matplotlib to animate circular orbits and demonstrate Kepler's Third Law:","title":"4. Python Computational Model:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() This animation clearly demonstrates a stable circular orbit around a central body (Earth), and the Python computation verifies the accuracy of Kepler\u2019s third law numerically.","title":"Python Implementation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-explanation-of-the-simulation-results","text":"The animation illustrates the orbital mechanics visually, showing a circular orbit around Earth. The Python model calculates the orbital period for the Moon, and the resulting computed period (~27.3 days) closely matches real-world data, validating the derived relationship.","title":"5. Explanation of the Simulation Results:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides an elegant yet powerful tool for astronomers and engineers. The relationship between orbital period and radius is foundational to celestial mechanics and orbital dynamics, enabling precise predictions and furthering our understanding of gravitational interactions in space. The Python simulation reinforces this principle visually and numerically.","title":"Conclusion:"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Below is a comprehensive Markdown document that explains the concepts of escape and cosmic velocities, walks through the derivations and calculations for Earth, Mars, and Jupiter, and includes both a Python simulation for plotting the velocities as well as a Java code snippet for an animation to be used in a presentation. Escape Velocities and Cosmic Velocities Introduction Escape and cosmic velocities are fundamental in understanding the energy requirements for space travel. In celestial mechanics, three key velocity thresholds are defined: First Cosmic Velocity: The minimum speed needed for a circular orbit around a celestial body. Second Cosmic Velocity: The speed required to break free from the gravitational influence of that body. Third Cosmic Velocity: The speed necessary to overcome the gravitational pull of an entire star system (e.g., leaving the Solar System). These concepts are critical when launching satellites, planning interplanetary missions, and even for envisaging potential interstellar travel. Definitions and Mathematical Derivations First Cosmic Velocity (Orbital Velocity) Definition: The minimum speed an object must have to enter a stable, circular orbit just above the surface of a planet. Formula: \\( \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) \\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is its radius. This expression comes from setting the gravitational force equal to the required centripetal force for circular motion. Second Cosmic Velocity (Escape Velocity) Definition: The minimum speed required for an object to escape the gravitational pull of a celestial body without further propulsion. Formula: $$v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}\\,v_1 $$ It is derived by equating the object\u2019s kinetic energy to the gravitational potential energy (with the condition that the total energy is zero at infinity). Third Cosmic Velocity (Interplanetary Escape Velocity) Definition: The velocity required to leave the gravitational influence of the star system from a planet\u2019s orbit. Formula: $$ v_{esc,\\odot} = \\sqrt{\\frac{2GM_\\odot}{r}} $$ where: - \\(M_\\odot\\) is the mass (or, more precisely, the gravitational parameter) of the Sun, - \\(r\\) is the distance from the Sun. This threshold indicates the additional energy required for a spacecraft to escape the solar gravitational field, once it has already overcome the planet\u2019s pull. Calculations for Different Celestial Bodies For our calculations, we use typical values for three celestial bodies: Earth: Mass, \\(M_{\\text{Earth}} = 5.972 \\times 10^{24}\\,\\text{kg}\\) Radius, \\(R_{\\text{Earth}} = 6.371 \\times 10^6\\,\\text{m}\\) Mars: Mass, \\(M_{\\text{Mars}} \\approx 6.39 \\times 10^{23}\\,\\text{kg}\\) Radius, \\(R_{\\text{Mars}} \\approx 3.3895 \\times 10^6\\,\\text{m}\\) Jupiter: Mass, \\(M_{\\text{Jupiter}} \\approx 1.898 \\times 10^{27}\\,\\text{kg}\\) Radius, \\(R_{\\text{Jupiter}} \\approx 6.9911 \\times 10^7\\,\\text{m}\\) In addition, to compute the third cosmic velocity, we use the Sun\u2019s gravitational parameter \\(GM_\\odot \\approx 1.327 \\times 10^{20}\\,\\text{m}^3/\\text{s}^2\\) and the average distances from the Sun: - Earth: \\(1.496 \\times 10^{11}\\,\\text{m}\\) - Mars: Approximately \\(2.279 \\times 10^{11}\\,\\text{m}\\) - Jupiter: Approximately \\(7.785 \\times 10^{11}\\,\\text{m}\\) Using the formulas: - First cosmic velocity: \\(\\displaystyle v_1 = \\sqrt{\\frac{GM}{R}}\\) - Second cosmic velocity: \\(\\displaystyle v_2 = \\sqrt{2}\\,v_1\\) - Third cosmic velocity (solar escape at orbit): \\(\\displaystyle v_3 = \\sqrt{\\frac{2GM_\\odot}{r}}\\) we can compare these velocities for the different bodies. Python Simulation for Visualization The following Python script calculates the three velocities for Earth, Mars, and Jupiter and visualizes them using a bar chart. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 GM_sun = 1.32712440018e20 # Sun's gravitational parameter in m^3/s^2 # Celestial bodies parameters bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'distance_sun': 1.496e11}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'distance_sun': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'distance_sun': 7.785e11} } # Compute velocities (in m/s) results = {} for body, params in bodies.items(): M = params['mass'] R = params['radius'] r_sun = params['distance_sun'] v1 = np.sqrt(G * M / R) # first cosmic velocity (orbital) v2 = np.sqrt(2) * v1 # second cosmic velocity (escape) v3 = np.sqrt(2 * GM_sun / r_sun) # third cosmic velocity (solar escape at orbit) # Convert velocities to km/s for readability results[body] = {'v1': v1/1000, 'v2': v2/1000, 'v3': v3/1000} # Print the computed values for body, vals in results.items(): print(f\"{body}: First = {vals['v1']:.2f} km/s, Second = {vals['v2']:.2f} km/s, Third = {vals['v3']:.2f} km/s\") # Plotting the velocities bodies_list = list(results.keys()) v1_values = [results[b]['v1'] for b in bodies_list] v2_values = [results[b]['v2'] for b in bodies_list] v3_values = [results[b]['v3'] for b in bodies_list] x = np.arange(len(bodies_list)) width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, v1_values, width, label='First Cosmic Velocity') ax.bar(x, v2_values, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_values, width, label='Third Cosmic Velocity (Solar)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(bodies_list) ax.legend() plt.show() When you run this script, it prints the velocity values and displays a bar chart comparing the three velocities for each celestial body. Java Animation Script for Presentation The following Java code snippet creates a simple animation using Swing. The animation simulates a rocket attempting to escape a planet\u2019s gravity, visually illustrating the concept of escape velocity. import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class EscapeVelocityAnimation extends JPanel implements ActionListener { private Timer timer; private double rocketY = 300; // initial Y position of the rocket private double velocity = -5; // initial upward velocity (negative indicates upward movement) private final double gravity = 0.1; // constant acceleration due to gravity public EscapeVelocityAnimation() { timer = new Timer(20, this); timer.start(); } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); // Draw the planet as a blue circle near the bottom g.setColor(Color.BLUE); g.fillOval(100, 350, 200, 200); // Draw the rocket as a red rectangle g.setColor(Color.RED); g.fillRect(190, (int) rocketY, 20, 40); // Display the current velocity g.setColor(Color.BLACK); g.drawString(\"Velocity: \" + String.format(\"%.2f\", velocity) + \" units\", 10, 20); } @Override public void actionPerformed(ActionEvent e) { // Update rocket's position and velocity rocketY += velocity; velocity += gravity; // gravity decelerates the rocket upward, then accelerates it downward // Reset the animation once the rocket \"lands\" again if (rocketY > 350) { rocketY = 300; velocity = -5; } repaint(); } public static void main(String[] args) { JFrame frame = new JFrame(\"Escape Velocity Animation\"); EscapeVelocityAnimation animation = new EscapeVelocityAnimation(); frame.add(animation); frame.setSize(400, 600); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); } } Compile and run this Java program to see a simple animation that conceptually demonstrates the rocket\u2019s ascent and the effect of gravity\u2014key to understanding the idea behind escape velocities. Importance in Space Exploration Satellite Launches: Achieving the first cosmic velocity allows satellites to maintain stable orbits for communication, weather monitoring, and scientific observation. Interplanetary Missions: Overcoming the second cosmic velocity is crucial for spacecraft to leave a planet\u2019s gravitational influence, and the third cosmic velocity determines the additional energy required to leave the solar system. Interstellar Travel: For future missions that aim to travel between stars, understanding and planning for these velocity thresholds is essential in designing propulsion systems and trajectories. Conclusion By mathematically deriving and visually simulating the first, second, and third cosmic velocities, we can appreciate the physics behind orbital maneuvers and escape trajectories. These principles not only enhance our understanding of celestial mechanics but also form the backbone of modern space exploration technologies. Whether launching satellites or planning interplanetary journeys, the study of cosmic velocities remains a cornerstone in advancing our reach into space. This visual representation helps clarify how material transitions from being gravitationally bound to unbound as its velocity increases. Feel free to run and modify the code to suit your presentation needs. Feel free to use and adapt the provided Python and Java scripts for your simulations and presentations.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Below is a comprehensive Markdown document that explains the concepts of escape and cosmic velocities, walks through the derivations and calculations for Earth, Mars, and Jupiter, and includes both a Python simulation for plotting the velocities as well as a Java code snippet for an animation to be used in a presentation.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"Escape and cosmic velocities are fundamental in understanding the energy requirements for space travel. In celestial mechanics, three key velocity thresholds are defined: First Cosmic Velocity: The minimum speed needed for a circular orbit around a celestial body. Second Cosmic Velocity: The speed required to break free from the gravitational influence of that body. Third Cosmic Velocity: The speed necessary to overcome the gravitational pull of an entire star system (e.g., leaving the Solar System). These concepts are critical when launching satellites, planning interplanetary missions, and even for envisaging potential interstellar travel.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-mathematical-derivations","text":"","title":"Definitions and Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition: The minimum speed an object must have to enter a stable, circular orbit just above the surface of a planet. Formula: \\( \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) \\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is its radius. This expression comes from setting the gravitational force equal to the required centripetal force for circular motion.","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition: The minimum speed required for an object to escape the gravitational pull of a celestial body without further propulsion. Formula: $$v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}\\,v_1 $$ It is derived by equating the object\u2019s kinetic energy to the gravitational potential energy (with the condition that the total energy is zero at infinity).","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interplanetary-escape-velocity","text":"Definition: The velocity required to leave the gravitational influence of the star system from a planet\u2019s orbit. Formula: $$ v_{esc,\\odot} = \\sqrt{\\frac{2GM_\\odot}{r}} $$ where: - \\(M_\\odot\\) is the mass (or, more precisely, the gravitational parameter) of the Sun, - \\(r\\) is the distance from the Sun. This threshold indicates the additional energy required for a spacecraft to escape the solar gravitational field, once it has already overcome the planet\u2019s pull.","title":"Third Cosmic Velocity (Interplanetary Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-different-celestial-bodies","text":"For our calculations, we use typical values for three celestial bodies: Earth: Mass, \\(M_{\\text{Earth}} = 5.972 \\times 10^{24}\\,\\text{kg}\\) Radius, \\(R_{\\text{Earth}} = 6.371 \\times 10^6\\,\\text{m}\\) Mars: Mass, \\(M_{\\text{Mars}} \\approx 6.39 \\times 10^{23}\\,\\text{kg}\\) Radius, \\(R_{\\text{Mars}} \\approx 3.3895 \\times 10^6\\,\\text{m}\\) Jupiter: Mass, \\(M_{\\text{Jupiter}} \\approx 1.898 \\times 10^{27}\\,\\text{kg}\\) Radius, \\(R_{\\text{Jupiter}} \\approx 6.9911 \\times 10^7\\,\\text{m}\\) In addition, to compute the third cosmic velocity, we use the Sun\u2019s gravitational parameter \\(GM_\\odot \\approx 1.327 \\times 10^{20}\\,\\text{m}^3/\\text{s}^2\\) and the average distances from the Sun: - Earth: \\(1.496 \\times 10^{11}\\,\\text{m}\\) - Mars: Approximately \\(2.279 \\times 10^{11}\\,\\text{m}\\) - Jupiter: Approximately \\(7.785 \\times 10^{11}\\,\\text{m}\\) Using the formulas: - First cosmic velocity: \\(\\displaystyle v_1 = \\sqrt{\\frac{GM}{R}}\\) - Second cosmic velocity: \\(\\displaystyle v_2 = \\sqrt{2}\\,v_1\\) - Third cosmic velocity (solar escape at orbit): \\(\\displaystyle v_3 = \\sqrt{\\frac{2GM_\\odot}{r}}\\) we can compare these velocities for the different bodies.","title":"Calculations for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-for-visualization","text":"The following Python script calculates the three velocities for Earth, Mars, and Jupiter and visualizes them using a bar chart. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 GM_sun = 1.32712440018e20 # Sun's gravitational parameter in m^3/s^2 # Celestial bodies parameters bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'distance_sun': 1.496e11}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'distance_sun': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'distance_sun': 7.785e11} } # Compute velocities (in m/s) results = {} for body, params in bodies.items(): M = params['mass'] R = params['radius'] r_sun = params['distance_sun'] v1 = np.sqrt(G * M / R) # first cosmic velocity (orbital) v2 = np.sqrt(2) * v1 # second cosmic velocity (escape) v3 = np.sqrt(2 * GM_sun / r_sun) # third cosmic velocity (solar escape at orbit) # Convert velocities to km/s for readability results[body] = {'v1': v1/1000, 'v2': v2/1000, 'v3': v3/1000} # Print the computed values for body, vals in results.items(): print(f\"{body}: First = {vals['v1']:.2f} km/s, Second = {vals['v2']:.2f} km/s, Third = {vals['v3']:.2f} km/s\") # Plotting the velocities bodies_list = list(results.keys()) v1_values = [results[b]['v1'] for b in bodies_list] v2_values = [results[b]['v2'] for b in bodies_list] v3_values = [results[b]['v3'] for b in bodies_list] x = np.arange(len(bodies_list)) width = 0.25 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, v1_values, width, label='First Cosmic Velocity') ax.bar(x, v2_values, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_values, width, label='Third Cosmic Velocity (Solar)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(bodies_list) ax.legend() plt.show() When you run this script, it prints the velocity values and displays a bar chart comparing the three velocities for each celestial body.","title":"Python Simulation for Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#java-animation-script-for-presentation","text":"The following Java code snippet creates a simple animation using Swing. The animation simulates a rocket attempting to escape a planet\u2019s gravity, visually illustrating the concept of escape velocity. import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class EscapeVelocityAnimation extends JPanel implements ActionListener { private Timer timer; private double rocketY = 300; // initial Y position of the rocket private double velocity = -5; // initial upward velocity (negative indicates upward movement) private final double gravity = 0.1; // constant acceleration due to gravity public EscapeVelocityAnimation() { timer = new Timer(20, this); timer.start(); } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); // Draw the planet as a blue circle near the bottom g.setColor(Color.BLUE); g.fillOval(100, 350, 200, 200); // Draw the rocket as a red rectangle g.setColor(Color.RED); g.fillRect(190, (int) rocketY, 20, 40); // Display the current velocity g.setColor(Color.BLACK); g.drawString(\"Velocity: \" + String.format(\"%.2f\", velocity) + \" units\", 10, 20); } @Override public void actionPerformed(ActionEvent e) { // Update rocket's position and velocity rocketY += velocity; velocity += gravity; // gravity decelerates the rocket upward, then accelerates it downward // Reset the animation once the rocket \"lands\" again if (rocketY > 350) { rocketY = 300; velocity = -5; } repaint(); } public static void main(String[] args) { JFrame frame = new JFrame(\"Escape Velocity Animation\"); EscapeVelocityAnimation animation = new EscapeVelocityAnimation(); frame.add(animation); frame.setSize(400, 600); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); } } Compile and run this Java program to see a simple animation that conceptually demonstrates the rocket\u2019s ascent and the effect of gravity\u2014key to understanding the idea behind escape velocities.","title":"Java Animation Script for Presentation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Satellite Launches: Achieving the first cosmic velocity allows satellites to maintain stable orbits for communication, weather monitoring, and scientific observation. Interplanetary Missions: Overcoming the second cosmic velocity is crucial for spacecraft to leave a planet\u2019s gravitational influence, and the third cosmic velocity determines the additional energy required to leave the solar system. Interstellar Travel: For future missions that aim to travel between stars, understanding and planning for these velocity thresholds is essential in designing propulsion systems and trajectories.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"By mathematically deriving and visually simulating the first, second, and third cosmic velocities, we can appreciate the physics behind orbital maneuvers and escape trajectories. These principles not only enhance our understanding of celestial mechanics but also form the backbone of modern space exploration technologies. Whether launching satellites or planning interplanetary journeys, the study of cosmic velocities remains a cornerstone in advancing our reach into space. This visual representation helps clarify how material transitions from being gravitationally bound to unbound as its velocity increases. Feel free to run and modify the code to suit your presentation needs. Feel free to use and adapt the provided Python and Java scripts for your simulations and presentations.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Below is a comprehensive Markdown document that explains the physics behind the trajectories of a freely released payload near Earth and provides a Python simulation to explore different scenarios (elliptical/orbital, reentry, and escape). The document details the underlying gravitational dynamics, the numerical approach used, and includes code and plots to visualize the trajectories. Trajectories of a Freely Released Payload Near Earth Overview When a payload is released from a moving rocket near Earth, its subsequent path is determined by the initial position, velocity, and the gravitational pull of the Earth. Depending on these factors, the payload may follow an elliptical (or circular), parabolic, or hyperbolic trajectory. Such analyses are crucial in space mission planning\u2014whether for inserting satellites into orbit, planning safe reentry trajectories, or achieving escape conditions. Key Concepts Newton\u2019s Law of Gravitation: The gravitational acceleration is given by \\[\\vec{a} = -\\frac{GM}{r^3} \\vec{r}\\] where \\(G\\) is the gravitational constant, \\(M\\) is the mass of Earth, and \\(r\\) is the distance from Earth\u2019s center. Orbital Velocities: Circular Orbit: The velocity required for a stable circular orbit at a distance \\(r\\) is \\[v_{\\text{circular}} = \\sqrt{\\frac{GM}{r}}\\] Escape Velocity: The speed needed to break free from Earth\u2019s gravitational influence is $$ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}}$$ Trajectory Types: Elliptical/Circular Orbits: Occur when the payload\u2019s speed is below escape velocity. Parabolic Trajectories: Represent the exact threshold case for escape. Hyperbolic Trajectories: Occur when the payload\u2019s speed exceeds escape velocity. Simulation and Numerical Analysis The simulation uses Python to solve the equations of motion numerically. We adopt the following steps: Define the Dynamics: The system\u2019s state is represented as $ [x, y, v_x, v_y] $. The time evolution is governed by: $$ \\frac{d}{dt}\\begin{bmatrix} x \\ y \\ v_x \\ v_y \\end{bmatrix} = \\begin{bmatrix} v_x \\ v_y \\ -\\frac{GMx}{r^3} \\ -\\frac{GMy}{r^3} \\end{bmatrix} $$ Initial Conditions: We consider a payload released at an altitude of 200 km above Earth\u2019s surface. Three scenarios are simulated: Circular Orbit: Velocity set to the circular orbit speed. Elliptical Orbit: A lower tangential velocity leading to an elliptical path (which may lead to reentry). Escape Trajectory: A speed greater than the escape velocity to produce a hyperbolic path. Numerical Integration: We use a solver (e.g., solve_ivp from SciPy) to integrate the motion over a specified time interval. Visualization: The trajectories are plotted with Earth shown as a circle. Python Code Implementation Below is the complete Python code that implements the simulation: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant [m^3 kg^-1 s^-2] M_earth = 5.972e24 # mass of Earth [kg] R_earth = 6371e3 # radius of Earth [m] def payload_dynamics(t, state): \"\"\" Computes the derivative of the state vector for the payload. Parameters: t (float): Time variable (not used explicitly as the problem is time-invariant). state (list or np.array): [x, y, vx, vy] current state of the payload. Returns: list: Derivatives [vx, vy, ax, ay] \"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) # Gravitational acceleration components ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] # Simulation parameters initial_altitude = 200e3 # altitude above Earth's surface in meters initial_r = R_earth + initial_altitude # Calculate velocities for different scenarios v_circular = np.sqrt(G * M_earth / initial_r) v_escape = np.sqrt(2 * G * M_earth / initial_r) # Define initial conditions for different trajectories: # Format: [x, y, vx, vy] initial_conditions = { 'circular': [initial_r, 0, 0, v_circular], 'elliptical': [initial_r, 0, -0.8*v_circular, v_circular], 'escape': [initial_r, 0, 0, 1.1*v_escape] } # Time span for the simulation (in seconds) t_span = (0, 5000) t_eval = np.linspace(t_span[0], t_span[1], 1000) # Prepare the plot plt.figure(figsize=(10, 8)) # Plot Earth as a circle theta = np.linspace(0, 2*np.pi, 1000) x_earth = R_earth * np.cos(theta) y_earth = R_earth * np.sin(theta) plt.plot(x_earth, y_earth, 'b', label='Earth') # Colors for different trajectories colors = {'circular': 'r', 'elliptical': 'g', 'escape': 'm'} # Numerical integration for each case for traj, ic in initial_conditions.items(): sol = solve_ivp(payload_dynamics, t_span, ic, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0], sol.y[1], color=colors[traj], label=traj) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Trajectories of a Freely Released Payload Near Earth\") plt.legend() plt.axis('equal') plt.grid(True) plt.show() Explanation of the Code Defining the Dynamics: The payload_dynamics function computes the state derivatives using the gravitational force. The acceleration is inversely proportional to \\(r^2\\) (with the \\(r^3\\) term ensuring directionality). Setting Initial Conditions: The payload starts at an altitude of 200 km above the surface. Three different initial velocity conditions are defined: Circular: Velocity equals \\(v_{\\text{circular}}\\) in the perpendicular direction. Elliptical: Velocity slightly reduced to induce an elliptical orbit. Escape: Velocity exceeds the escape speed, leading to a hyperbolic path. Numerical Integration: We use solve_ivp to integrate the equations over 5000 seconds, capturing the trajectory at 1000 time steps. Visualization: The plot shows Earth (as a blue circle) and the three trajectories in different colors (red for circular, green for elliptical, and magenta for escape). Discussion Orbital Insertion (Circular/Elliptical): When the payload is given the correct tangential velocity, it enters a stable circular orbit. A reduction in speed (elliptical case) results in an orbit with a lower perigee, potentially leading to reentry if the perigee is below Earth's atmosphere. Escape Scenario: If the payload's velocity exceeds the escape velocity, its path will be open (hyperbolic trajectory) meaning it will eventually leave Earth's gravitational influence. Applications: This simulation is fundamental in designing maneuvers for satellite deployments, planning safe reentry trajectories, and executing missions where escape trajectories are required (e.g., interplanetary travel). This document provides both the theoretical framework and practical implementation to analyze the trajectories of a payload released near Earth. Feel free to adjust the initial conditions or extend the simulation further for more complex scenarios.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Below is a comprehensive Markdown document that explains the physics behind the trajectories of a freely released payload near Earth and provides a Python simulation to explore different scenarios (elliptical/orbital, reentry, and escape). The document details the underlying gravitational dynamics, the numerical approach used, and includes code and plots to visualize the trajectories.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#overview","text":"When a payload is released from a moving rocket near Earth, its subsequent path is determined by the initial position, velocity, and the gravitational pull of the Earth. Depending on these factors, the payload may follow an elliptical (or circular), parabolic, or hyperbolic trajectory. Such analyses are crucial in space mission planning\u2014whether for inserting satellites into orbit, planning safe reentry trajectories, or achieving escape conditions.","title":"Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-concepts","text":"Newton\u2019s Law of Gravitation: The gravitational acceleration is given by \\[\\vec{a} = -\\frac{GM}{r^3} \\vec{r}\\] where \\(G\\) is the gravitational constant, \\(M\\) is the mass of Earth, and \\(r\\) is the distance from Earth\u2019s center. Orbital Velocities: Circular Orbit: The velocity required for a stable circular orbit at a distance \\(r\\) is \\[v_{\\text{circular}} = \\sqrt{\\frac{GM}{r}}\\] Escape Velocity: The speed needed to break free from Earth\u2019s gravitational influence is $$ v_{\\text{escape}} = \\sqrt{\\frac{2GM}{r}}$$ Trajectory Types: Elliptical/Circular Orbits: Occur when the payload\u2019s speed is below escape velocity. Parabolic Trajectories: Represent the exact threshold case for escape. Hyperbolic Trajectories: Occur when the payload\u2019s speed exceeds escape velocity.","title":"Key Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-and-numerical-analysis","text":"The simulation uses Python to solve the equations of motion numerically. We adopt the following steps: Define the Dynamics: The system\u2019s state is represented as $ [x, y, v_x, v_y] $. The time evolution is governed by: $$ \\frac{d}{dt}\\begin{bmatrix} x \\ y \\ v_x \\ v_y \\end{bmatrix} = \\begin{bmatrix} v_x \\ v_y \\ -\\frac{GMx}{r^3} \\ -\\frac{GMy}{r^3} \\end{bmatrix} $$ Initial Conditions: We consider a payload released at an altitude of 200 km above Earth\u2019s surface. Three scenarios are simulated: Circular Orbit: Velocity set to the circular orbit speed. Elliptical Orbit: A lower tangential velocity leading to an elliptical path (which may lead to reentry). Escape Trajectory: A speed greater than the escape velocity to produce a hyperbolic path. Numerical Integration: We use a solver (e.g., solve_ivp from SciPy) to integrate the motion over a specified time interval. Visualization: The trajectories are plotted with Earth shown as a circle.","title":"Simulation and Numerical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-implementation","text":"Below is the complete Python code that implements the simulation: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant [m^3 kg^-1 s^-2] M_earth = 5.972e24 # mass of Earth [kg] R_earth = 6371e3 # radius of Earth [m] def payload_dynamics(t, state): \"\"\" Computes the derivative of the state vector for the payload. Parameters: t (float): Time variable (not used explicitly as the problem is time-invariant). state (list or np.array): [x, y, vx, vy] current state of the payload. Returns: list: Derivatives [vx, vy, ax, ay] \"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) # Gravitational acceleration components ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] # Simulation parameters initial_altitude = 200e3 # altitude above Earth's surface in meters initial_r = R_earth + initial_altitude # Calculate velocities for different scenarios v_circular = np.sqrt(G * M_earth / initial_r) v_escape = np.sqrt(2 * G * M_earth / initial_r) # Define initial conditions for different trajectories: # Format: [x, y, vx, vy] initial_conditions = { 'circular': [initial_r, 0, 0, v_circular], 'elliptical': [initial_r, 0, -0.8*v_circular, v_circular], 'escape': [initial_r, 0, 0, 1.1*v_escape] } # Time span for the simulation (in seconds) t_span = (0, 5000) t_eval = np.linspace(t_span[0], t_span[1], 1000) # Prepare the plot plt.figure(figsize=(10, 8)) # Plot Earth as a circle theta = np.linspace(0, 2*np.pi, 1000) x_earth = R_earth * np.cos(theta) y_earth = R_earth * np.sin(theta) plt.plot(x_earth, y_earth, 'b', label='Earth') # Colors for different trajectories colors = {'circular': 'r', 'elliptical': 'g', 'escape': 'm'} # Numerical integration for each case for traj, ic in initial_conditions.items(): sol = solve_ivp(payload_dynamics, t_span, ic, t_eval=t_eval, rtol=1e-8) plt.plot(sol.y[0], sol.y[1], color=colors[traj], label=traj) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Trajectories of a Freely Released Payload Near Earth\") plt.legend() plt.axis('equal') plt.grid(True) plt.show()","title":"Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-of-the-code","text":"Defining the Dynamics: The payload_dynamics function computes the state derivatives using the gravitational force. The acceleration is inversely proportional to \\(r^2\\) (with the \\(r^3\\) term ensuring directionality). Setting Initial Conditions: The payload starts at an altitude of 200 km above the surface. Three different initial velocity conditions are defined: Circular: Velocity equals \\(v_{\\text{circular}}\\) in the perpendicular direction. Elliptical: Velocity slightly reduced to induce an elliptical orbit. Escape: Velocity exceeds the escape speed, leading to a hyperbolic path. Numerical Integration: We use solve_ivp to integrate the equations over 5000 seconds, capturing the trajectory at 1000 time steps. Visualization: The plot shows Earth (as a blue circle) and the three trajectories in different colors (red for circular, green for elliptical, and magenta for escape).","title":"Explanation of the Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"Orbital Insertion (Circular/Elliptical): When the payload is given the correct tangential velocity, it enters a stable circular orbit. A reduction in speed (elliptical case) results in an orbit with a lower perigee, potentially leading to reentry if the perigee is below Earth's atmosphere. Escape Scenario: If the payload's velocity exceeds the escape velocity, its path will be open (hyperbolic trajectory) meaning it will eventually leave Earth's gravitational influence. Applications: This simulation is fundamental in designing maneuvers for satellite deployments, planning safe reentry trajectories, and executing missions where escape trajectories are required (e.g., interplanetary travel). This document provides both the theoretical framework and practical implementation to analyze the trajectories of a payload released near Earth. Feel free to adjust the initial conditions or extend the simulation further for more complex scenarios.","title":"Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Sure! Let's walk through a clear explanation of the problem and then dive into interference pattern simulations for a square setup using 2 and 3 point sources . \ud83d\udcdd Problem Explanation: Interference Patterns on a Water Surface Goal : Simulate and visualize wave interference patterns from multiple point wave sources placed at the vertices of a regular polygon (e.g., triangle, square, etc.). Each wave source generates a 2D wave given by this formula: \\[\\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos\\left(k r_i - \\omega t + \\phi_i\\right)\\] Where: \\(A\\) is the amplitude \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the source \\(i\\) to point \\((x, y)\\) \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number \\(\\omega = 2\\pi f\\) is the angular frequency \\(\\phi_i\\) is the initial phase (we can assume it's zero for all sources in coherent case) \ud83d\udca1 Physical Context: When multiple waves overlap in space and time, interference occurs: - Constructive interference when wave peaks align (bright spots) - Destructive interference when peaks meet troughs (dark zones) \ud83e\uddea Example: Simulate a Square with 2 and 3 Sources We'll use Python and Matplotlib to simulate two cases: - 2 sources (opposite corners of a square) - 3 sources (3 corners of a square) \u25b6 Case 1: 2 Point Sources (Opposite corners of a square) import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 \u03bb = 1.0 k = 2 * np.pi / \u03bb f = 1.0 \u03c9 = 2 * np.pi * f t = 0 # snapshot in time \u03c6 = 0 # Grid setup x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # 2 sources at opposite corners of a square L = 4 sources_2 = [ (-L/2, -L/2), ( L/2, L/2) ] # Superposition of 2 sources \u03b7_2 = np.zeros_like(X) for (x0, y0) in sources_2: R = np.sqrt((X - x0)**2 + (Y - y0)**2) \u03b7_2 += A / np.sqrt(R + 1e-6) * np.cos(k * R - \u03c9 * t + \u03c6) # Plot 2-source pattern plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, \u03b7_2, shading='auto', cmap='plasma') plt.colorbar(label='Wave Displacement \u03b7(x, y)') plt.title('Interference Pattern from 2 Sources (Opposite Corners)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() \u25b6 Case 2: 3 Point Sources (3 corners of a square) # 3 sources at three corners of a square sources_3 = [ (-L/2, -L/2), ( L/2, -L/2), (-L/2, L/2) ] # Superposition of 3 sources \u03b7_3 = np.zeros_like(X) for (x0, y0) in sources_3: R = np.sqrt((X - x0)**2 + (Y - y0)**2) \u03b7_3 += A / np.sqrt(R + 1e-6) * np.cos(k * R - \u03c9 * t + \u03c6) # Plot 3-source pattern plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, \u03b7_3, shading='auto', cmap='plasma') plt.colorbar(label='Wave Displacement \u03b7(x, y)') plt.title('Interference Pattern from 3 Sources (3 Corners of a Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() \ud83d\udd0e Observations: With 2 sources , the pattern is more symmetric and shows classic two-point interference (like in Young\u2019s double slit). 3 sources create a more complex pattern with asymmetries due to the uneven triangle shape.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-explanation-interference-patterns-on-a-water-surface","text":"Goal : Simulate and visualize wave interference patterns from multiple point wave sources placed at the vertices of a regular polygon (e.g., triangle, square, etc.). Each wave source generates a 2D wave given by this formula: \\[\\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos\\left(k r_i - \\omega t + \\phi_i\\right)\\] Where: \\(A\\) is the amplitude \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the source \\(i\\) to point \\((x, y)\\) \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number \\(\\omega = 2\\pi f\\) is the angular frequency \\(\\phi_i\\) is the initial phase (we can assume it's zero for all sources in coherent case)","title":"\ud83d\udcdd Problem Explanation: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#physical-context","text":"When multiple waves overlap in space and time, interference occurs: - Constructive interference when wave peaks align (bright spots) - Destructive interference when peaks meet troughs (dark zones)","title":"\ud83d\udca1 Physical Context:"},{"location":"1%20Physics/3%20Waves/Problem_1/#example-simulate-a-square-with-2-and-3-sources","text":"We'll use Python and Matplotlib to simulate two cases: - 2 sources (opposite corners of a square) - 3 sources (3 corners of a square)","title":"\ud83e\uddea Example: Simulate a Square with 2 and 3 Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#case-1-2-point-sources-opposite-corners-of-a-square","text":"import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 \u03bb = 1.0 k = 2 * np.pi / \u03bb f = 1.0 \u03c9 = 2 * np.pi * f t = 0 # snapshot in time \u03c6 = 0 # Grid setup x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # 2 sources at opposite corners of a square L = 4 sources_2 = [ (-L/2, -L/2), ( L/2, L/2) ] # Superposition of 2 sources \u03b7_2 = np.zeros_like(X) for (x0, y0) in sources_2: R = np.sqrt((X - x0)**2 + (Y - y0)**2) \u03b7_2 += A / np.sqrt(R + 1e-6) * np.cos(k * R - \u03c9 * t + \u03c6) # Plot 2-source pattern plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, \u03b7_2, shading='auto', cmap='plasma') plt.colorbar(label='Wave Displacement \u03b7(x, y)') plt.title('Interference Pattern from 2 Sources (Opposite Corners)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"\u25b6 Case 1: 2 Point Sources (Opposite corners of a square)"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#case-2-3-point-sources-3-corners-of-a-square","text":"# 3 sources at three corners of a square sources_3 = [ (-L/2, -L/2), ( L/2, -L/2), (-L/2, L/2) ] # Superposition of 3 sources \u03b7_3 = np.zeros_like(X) for (x0, y0) in sources_3: R = np.sqrt((X - x0)**2 + (Y - y0)**2) \u03b7_3 += A / np.sqrt(R + 1e-6) * np.cos(k * R - \u03c9 * t + \u03c6) # Plot 3-source pattern plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, \u03b7_3, shading='auto', cmap='plasma') plt.colorbar(label='Wave Displacement \u03b7(x, y)') plt.title('Interference Pattern from 3 Sources (3 Corners of a Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"\u25b6 Case 2: 3 Point Sources (3 corners of a square)"},{"location":"1%20Physics/3%20Waves/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"With 2 sources , the pattern is more symmetric and shows classic two-point interference (like in Young\u2019s double slit). 3 sources create a more complex pattern with asymmetries due to the uneven triangle shape.","title":"\ud83d\udd0e Observations:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u26a1 The Lorentz Force in Action: Simulating Charged Particle Motion \ud83d\udccc 1. Introduction The Lorentz force governs how charged particles move in the presence of electric and magnetic fields: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: - $ \\vec{F} $: Total force on the particle $ q $: Particle charge $ \\vec{E} $: Electric field $ \\vec{v} $: Particle velocity $ \\vec{B} $: Magnetic field This principle is fundamental in fields such as: - Particle accelerators Mass spectrometry Plasma confinement systems Astrophysical particle dynamics \ud83d\udd2c 2. Exploration of Applications System Role of Lorentz Force Cyclotrons Magnetic fields bend charged particles into circular paths. Mass Spectrometers Electric and magnetic fields help identify ions by their mass-to-charge ratio. Plasma Confinement (e.g., Tokamaks) Magnetic fields confine plasma and control its motion. Auroras / Astrophysics Charged particles spiral along Earth\u2019s magnetic field lines. \ud83e\uddea 3. Simulation Setup We\u2019ll simulate particle motion under: - Uniform magnetic field - Uniform electric + magnetic fields - Crossed electric and magnetic fields (E \u22a5 B) We\u2019ll solve Newton\u2019s second law: $$ m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q\\vec{v} \\times \\vec{B} $$ \u2705 Features: Adjustable $ \\vec{E}, \\vec{B}, q, m, \\vec{v_0} $ 2D and 3D plots of trajectories Real-time visualization \ud83e\uddee 4. Python Code Snippet (Skeleton) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge m = 1.0 # Mass dt = 0.01 # Time step steps = 1000 # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field # Initial conditions v = np.array([1.0, 0.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position trajectory = [] # Time evolution for _ in range(steps): # Store current position trajectory.append(r.copy()) # Compute Lorentz force F = q * (E + np.cross(v, B)) a = F / m # Update velocity and position v = v + a * dt r = r + v * dt trajectory = np.array(trajectory) # Visualization fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2]) ax.set_title(\"Particle Trajectory under Lorentz Force\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") plt.tight_layout() plt.show() \ud83d\udd04 5. Parameter Exploration Try modifying these: - $ B = [0, 0, 1] \\rightarrow [0, 1, 1] $ $ E = [0, 0, 0] \\rightarrow [1, 0, 0] $ $ q = +1 \\rightarrow -1 $ $ v_0 = [1, 0, 0] \\rightarrow [1, 1, 0] $ Observe: - Circular motion under only B - Helical motion with both E and B - Drift motion in crossed E and B \ud83d\udcca 6. Visualizations We'll generate: - 2D XY/ZY projections for planar motion - 3D plots for helices and drifts - Optionally: animation of the path over time \ud83d\udca1 7. Discussion: Real-World Implications System What Simulation Shows Cyclotron Circular motion in constant B field. Frequency depends on $ q/m $. Mass Spectrometer Trajectories bend more for lighter particles. Magnetic Traps Particles spiral and are confined in B field \u201cbottles\u201d. \ud83e\udde0 8. Future Extensions Non-uniform fields : Varying $ \\vec{E}(r), \\vec{B}(r) $ Relativistic corrections for high-speed particles Collisions : Add interactions between particles Multiple particles : Simulate beam dynamics or plasma","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#the-lorentz-force-in-action-simulating-charged-particle-motion","text":"","title":"\u26a1 The Lorentz Force in Action: Simulating Charged Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction","text":"The Lorentz force governs how charged particles move in the presence of electric and magnetic fields: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: - $ \\vec{F} $: Total force on the particle $ q $: Particle charge $ \\vec{E} $: Electric field $ \\vec{v} $: Particle velocity $ \\vec{B} $: Magnetic field This principle is fundamental in fields such as: - Particle accelerators Mass spectrometry Plasma confinement systems Astrophysical particle dynamics","title":"\ud83d\udccc 1. Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-exploration-of-applications","text":"System Role of Lorentz Force Cyclotrons Magnetic fields bend charged particles into circular paths. Mass Spectrometers Electric and magnetic fields help identify ions by their mass-to-charge ratio. Plasma Confinement (e.g., Tokamaks) Magnetic fields confine plasma and control its motion. Auroras / Astrophysics Charged particles spiral along Earth\u2019s magnetic field lines.","title":"\ud83d\udd2c 2. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulation-setup","text":"We\u2019ll simulate particle motion under: - Uniform magnetic field - Uniform electric + magnetic fields - Crossed electric and magnetic fields (E \u22a5 B) We\u2019ll solve Newton\u2019s second law: $$ m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q\\vec{v} \\times \\vec{B} $$","title":"\ud83e\uddea 3. Simulation Setup"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#features","text":"Adjustable $ \\vec{E}, \\vec{B}, q, m, \\vec{v_0} $ 2D and 3D plots of trajectories Real-time visualization","title":"\u2705 Features:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-python-code-snippet-skeleton","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge m = 1.0 # Mass dt = 0.01 # Time step steps = 1000 # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field # Initial conditions v = np.array([1.0, 0.0, 0.0]) # Initial velocity r = np.array([0.0, 0.0, 0.0]) # Initial position trajectory = [] # Time evolution for _ in range(steps): # Store current position trajectory.append(r.copy()) # Compute Lorentz force F = q * (E + np.cross(v, B)) a = F / m # Update velocity and position v = v + a * dt r = r + v * dt trajectory = np.array(trajectory) # Visualization fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2]) ax.set_title(\"Particle Trajectory under Lorentz Force\") ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") plt.tight_layout() plt.show()","title":"\ud83e\uddee 4. Python Code Snippet (Skeleton)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-parameter-exploration","text":"Try modifying these: - $ B = [0, 0, 1] \\rightarrow [0, 1, 1] $ $ E = [0, 0, 0] \\rightarrow [1, 0, 0] $ $ q = +1 \\rightarrow -1 $ $ v_0 = [1, 0, 0] \\rightarrow [1, 1, 0] $ Observe: - Circular motion under only B - Helical motion with both E and B - Drift motion in crossed E and B","title":"\ud83d\udd04 5. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-visualizations","text":"We'll generate: - 2D XY/ZY projections for planar motion - 3D plots for helices and drifts - Optionally: animation of the path over time","title":"\ud83d\udcca 6. Visualizations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-discussion-real-world-implications","text":"System What Simulation Shows Cyclotron Circular motion in constant B field. Frequency depends on $ q/m $. Mass Spectrometer Trajectories bend more for lighter particles. Magnetic Traps Particles spiral and are confined in B field \u201cbottles\u201d.","title":"\ud83d\udca1 7. Discussion: Real-World Implications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#8-future-extensions","text":"Non-uniform fields : Varying $ \\vec{E}(r), \\vec{B}(r) $ Relativistic corrections for high-speed particles Collisions : Add interactions between particles Multiple particles : Simulate beam dynamics or plasma","title":"\ud83e\udde0 8. Future Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Great! Here's a complete solution for the Equivalent Resistance Using Graph Theory problem, using Python and the networkx library. \ud83d\udd27 Core Algorithm Features Simplifies circuits using series and parallel reduction. Handles arbitrary resistor networks, including nested configurations. Falls back to an advanced solver (nodal analysis) for complex circuits. \ud83d\udccc Key Concepts Explained Series Detection : If a node has exactly two neighbors and isn't an endpoint, we replace the two connecting resistors with a single equivalent resistor ( R1 + R2 ). Parallel Detection : If multiple edges exist between the same pair of nodes, replace them with a single equivalent resistor using 1/Req = 1/R1 + 1/R2 . Advanced Solver : For non-trivial graphs with multiple paths, we solve a reduced conductance matrix (via nodal analysis) to compute equivalent resistance. \ud83e\uddea Tested Examples Triangle graph with a shortcut ( A-B-C , A-C ). Parallel resistors ( A-B with two parallel resistors). Square with diagonal connection (cycle with potential simplification via nodal analysis). \ud83d\udcc8 Efficiency and Improvements Current implementation simplifies using repeated graph rewrites \u2014 good for medium-size circuits. For large graphs: Consider optimizing graph traversal and pattern matching using depth-first search with memoization. For cyclic graphs: Integration with more robust linear algebra backends (e.g., scipy.sparse ) would improve performance. import networkx as nx def calculate_equivalent_resistance(graph, start, end): def simplify_series(graph): changed = True while changed: changed = False for node in list(graph.nodes): if node not in [start, end] and graph.degree[node] == 2: neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: r1 = graph[node][neighbors[0]]['resistance'] r2 = graph[node][neighbors[1]]['resistance'] graph.add_edge(neighbors[0], neighbors[1], resistance=r1 + r2) graph.remove_node(node) changed = True break return graph def simplify_parallel(graph): changed = True while changed: changed = False seen_edges = {} for u, v, data in list(graph.edges(data=True)): key = tuple(sorted((u, v))) if key in seen_edges: r1 = seen_edges[key]['resistance'] r2 = data['resistance'] req = 1 / (1 / r1 + 1 / r2) graph.remove_edge(u, v) graph.remove_edge(*key) graph.add_edge(*key, resistance=req) changed = True break else: seen_edges[key] = data return graph graph = simplify_series(graph) graph = simplify_parallel(graph) try: paths = list(nx.all_simple_paths(graph, source=start, target=end)) if len(paths) == 1: path = paths[0] total_resistance = 0 for i in range(len(path) - 1): total_resistance += graph[path[i]][path[i + 1]]['resistance'] return total_resistance except: return float('inf') # fallback to resistance calculation using conductance matrix (advanced) return advanced_resistance_solver(graph, start, end) def advanced_resistance_solver(graph, start, end): import numpy as np nodes = list(graph.nodes()) node_index = {node: idx for idx, node in enumerate(nodes)} n = len(nodes) G = np.zeros((n, n)) for u, v, data in graph.edges(data=True): i, j = node_index[u], node_index[v] r = data['resistance'] G[i][i] += 1 / r G[j][j] += 1 / r G[i][j] -= 1 / r G[j][i] -= 1 / r # Apply boundary conditions start_idx = node_index[start] end_idx = node_index[end] # Remove one row and column to make G invertible G_reduced = np.delete(G, end_idx, axis=0) G_reduced = np.delete(G_reduced, end_idx, axis=1) b = np.zeros(n - 1) b[start_idx if start_idx < end_idx else start_idx - 1] = 1 v = np.linalg.solve(G_reduced, b) v_start = v[start_idx if start_idx < end_idx else start_idx - 1] return 1 / v_start Example use cases: G1 = nx.Graph() G1.add_edge('A', 'B', resistance=5) G1.add_edge('B', 'C', resistance=10) G1.add_edge('A', 'C', resistance=2) G2 = nx.Graph() G2.add_edge('A', 'B', resistance=3) G2.add_edge('A', 'B', resistance=6) G3 = nx.Graph() G3.add_edge('A', 'B', resistance=4) G3.add_edge('B', 'C', resistance=4) G3.add_edge('C', 'D', resistance=4) G3.add_edge('A', 'D', resistance=4) print(\"Example 1 Equivalent Resistance:\", calculate_equivalent_resistance(G1, 'A', 'C')) print(\"Example 2 Equivalent Resistance:\", calculate_equivalent_resistance(G2, 'A', 'B')) print(\"Example 3 Equivalent Resistance:\", calculate_equivalent_resistance(G3, 'A', 'D'))","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"Great! Here's a complete solution for the Equivalent Resistance Using Graph Theory problem, using Python and the networkx library.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#core-algorithm-features","text":"Simplifies circuits using series and parallel reduction. Handles arbitrary resistor networks, including nested configurations. Falls back to an advanced solver (nodal analysis) for complex circuits.","title":"\ud83d\udd27 Core Algorithm Features"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts-explained","text":"Series Detection : If a node has exactly two neighbors and isn't an endpoint, we replace the two connecting resistors with a single equivalent resistor ( R1 + R2 ). Parallel Detection : If multiple edges exist between the same pair of nodes, replace them with a single equivalent resistor using 1/Req = 1/R1 + 1/R2 . Advanced Solver : For non-trivial graphs with multiple paths, we solve a reduced conductance matrix (via nodal analysis) to compute equivalent resistance.","title":"\ud83d\udccc Key Concepts Explained"},{"location":"1%20Physics/5%20Circuits/Problem_1/#tested-examples","text":"Triangle graph with a shortcut ( A-B-C , A-C ). Parallel resistors ( A-B with two parallel resistors). Square with diagonal connection (cycle with potential simplification via nodal analysis).","title":"\ud83e\uddea Tested Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-and-improvements","text":"Current implementation simplifies using repeated graph rewrites \u2014 good for medium-size circuits. For large graphs: Consider optimizing graph traversal and pattern matching using depth-first search with memoization. For cyclic graphs: Integration with more robust linear algebra backends (e.g., scipy.sparse ) would improve performance. import networkx as nx def calculate_equivalent_resistance(graph, start, end): def simplify_series(graph): changed = True while changed: changed = False for node in list(graph.nodes): if node not in [start, end] and graph.degree[node] == 2: neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: r1 = graph[node][neighbors[0]]['resistance'] r2 = graph[node][neighbors[1]]['resistance'] graph.add_edge(neighbors[0], neighbors[1], resistance=r1 + r2) graph.remove_node(node) changed = True break return graph def simplify_parallel(graph): changed = True while changed: changed = False seen_edges = {} for u, v, data in list(graph.edges(data=True)): key = tuple(sorted((u, v))) if key in seen_edges: r1 = seen_edges[key]['resistance'] r2 = data['resistance'] req = 1 / (1 / r1 + 1 / r2) graph.remove_edge(u, v) graph.remove_edge(*key) graph.add_edge(*key, resistance=req) changed = True break else: seen_edges[key] = data return graph graph = simplify_series(graph) graph = simplify_parallel(graph) try: paths = list(nx.all_simple_paths(graph, source=start, target=end)) if len(paths) == 1: path = paths[0] total_resistance = 0 for i in range(len(path) - 1): total_resistance += graph[path[i]][path[i + 1]]['resistance'] return total_resistance except: return float('inf') # fallback to resistance calculation using conductance matrix (advanced) return advanced_resistance_solver(graph, start, end) def advanced_resistance_solver(graph, start, end): import numpy as np nodes = list(graph.nodes()) node_index = {node: idx for idx, node in enumerate(nodes)} n = len(nodes) G = np.zeros((n, n)) for u, v, data in graph.edges(data=True): i, j = node_index[u], node_index[v] r = data['resistance'] G[i][i] += 1 / r G[j][j] += 1 / r G[i][j] -= 1 / r G[j][i] -= 1 / r # Apply boundary conditions start_idx = node_index[start] end_idx = node_index[end] # Remove one row and column to make G invertible G_reduced = np.delete(G, end_idx, axis=0) G_reduced = np.delete(G_reduced, end_idx, axis=1) b = np.zeros(n - 1) b[start_idx if start_idx < end_idx else start_idx - 1] = 1 v = np.linalg.solve(G_reduced, b) v_start = v[start_idx if start_idx < end_idx else start_idx - 1] return 1 / v_start","title":"\ud83d\udcc8 Efficiency and Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-use-cases","text":"G1 = nx.Graph() G1.add_edge('A', 'B', resistance=5) G1.add_edge('B', 'C', resistance=10) G1.add_edge('A', 'C', resistance=2) G2 = nx.Graph() G2.add_edge('A', 'B', resistance=3) G2.add_edge('A', 'B', resistance=6) G3 = nx.Graph() G3.add_edge('A', 'B', resistance=4) G3.add_edge('B', 'C', resistance=4) G3.add_edge('C', 'D', resistance=4) G3.add_edge('A', 'D', resistance=4) print(\"Example 1 Equivalent Resistance:\", calculate_equivalent_resistance(G1, 'A', 'C')) print(\"Example 2 Equivalent Resistance:\", calculate_equivalent_resistance(G2, 'A', 'B')) print(\"Example 3 Equivalent Resistance:\", calculate_equivalent_resistance(G3, 'A', 'D'))","title":"Example use cases:"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}