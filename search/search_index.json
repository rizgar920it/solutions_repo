{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 1. Theoretical Foundation Projectile motion is a classic application of Newton\u2019s laws in two dimensions. Let\u2019s derive the governing equations from first principles, assuming no air resistance and a constant gravitational field, to establish the framework. Derivation of the Equations of Motion Consider a projectile launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The initial velocity components are: Horizontal: \\(v_{x0} = v_0 \\cos\\theta\\) Vertical: \\(v_{y0} = v_0 \\sin\\theta\\) The only acceleration is due to gravity, acting downward: \\(a_y = -g\\) , where \\(g \\approx 9.8 \\, \\text{m/s}^2\\) , and \\(a_x = 0\\) . Starting with the kinematic equations: Horizontal Motion Acceleration: \\(\\frac{d^2 x}{dt^2} = 0\\) Velocity: \\(\\frac{dx}{dt} = v_{x0} = v_0 \\cos\\theta\\) Position: \\(x(t) = v_0 \\cos\\theta \\cdot t\\) Vertical Motion Acceleration: \\(\\frac{d^2 y}{dt^2} = -g\\) Velocity: \\(\\frac{dy}{dt} = v_{y0} - g t = v_0 \\sin\\theta - g t\\) Position: Integrate velocity: \\(y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\) These are the parametric equations of motion, forming a parabola under ideal conditions. Family of Solutions The solutions depend on free parameters: \\(v_0\\) , \\(\\theta\\) , and \\(g\\) . Additionally, if launched from a height \\(h\\) (i.e., \\(y_0 = h\\) ), the vertical position becomes: \\[y(t) = h + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\] Varying \\(v_0\\) , \\(\\theta\\) , \\(g\\) , or \\(h\\) generates a family of trajectories, from shallow arcs to steep climbs, adaptable to diverse scenarios. 2. Analysis of the Range The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . For launch height \\(h = 0\\) : Time of Flight Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ - Trivial solution: \\(t = 0s\\) (start) - Non-trivial: \\((t = \\frac{2 v_0 \\sin\\theta}{g})\\) Range Equation Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\( \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) \\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ Dependence on Angle Maximum Range : \\(R\\) is maximized when \\(\\sin 2\\theta = 1\\) , so \\(2\\theta = 90^\\circ\\) , \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . Symmetry : \\(R(\\theta) = R(90^\\circ - \\theta)\\) , e.g., \\(15^\\circ\\) and \\(75^\\circ\\) yield the same range. Limits : At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) . Influence of Parameters Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) , a quadratic increase. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) , inversely proportional. On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), range is ~6 times greater than Earth\u2019s. Launch Height ( \\(h > 0\\) ) : Increases time of flight, thus extending range. Requires solving a quadratic for \\(t\\) , complicating the expression. 3. Practical Applications This model applies to: - Sports : Optimizing a basketball shot or golf drive ( \\(\\theta \\approx 45^\\circ\\) for flat ground). - Engineering : Artillery or rocket launches, adjusting for terrain or wind. - Astrophysics : Simplified trajectories of celestial bodies (neglecting orbital mechanics). For uneven terrain (landing at \\(y = h_f\\) ), modify the range calculation. With air resistance, numerical methods (e.g., Euler or Runge-Kutta) are needed, reducing range and altering the optimal angle. 4. Implementation Here\u2019s a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta_deg, g=9.8, h=0): theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # Time of flight with initial height a = -g / 2 b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 20, 30] # m/s g = 9.8 # m/s^2 theta_deg = np.arange(0, 91, 1) h_values = [0, 10] # m # Plotting plt.figure(figsize=(10, 6)) for v0 in v0_values: R = [projectile_range(v0, t, g, h=0) for t in theta_deg] plt.plot(theta_deg, R, label=f'v0 = {v0} m/s, h = 0 m') for h in h_values: R = [projectile_range(20, t, g, h) for t in theta_deg] plt.plot(theta_deg, R, '--', label=f'v0 = 20 m/s, h = {h} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() Output This generates a plot showing: - Range peaking at \\(45^\\circ\\) for \\(h = 0\\) . - Increased range with higher \\(v_0\\) . - Extended range and shifted optimal angle $below \\(45^\\circ\\) with \\(h > 0\\) . Discussion Limitations Idealization : Assumes no air resistance, flat terrain, and constant \\(g\\) . Realism : Drag reduces range and shifts the optimal angle (e.g., ~30\u201340\u00b0 for a golf ball). Extensions Drag : Incorporate \\(-k v\\) terms, solved numerically. Wind : Add velocity components to \\(v_x\\) and \\(v_y\\) . Terrain : Model \\(y = f(x)\\) for landing height. This framework, while simple, is a stepping stone to complex simulations in physics and engineering. This delivers a theoretical foundation, analytical insights, a practical implementation, and a discussion of real-world adaptations. Let me know if you\u2019d like to refine any section or explore extensions like air resistance numerically!","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is a classic application of Newton\u2019s laws in two dimensions. Let\u2019s derive the governing equations from first principles, assuming no air resistance and a constant gravitational field, to establish the framework.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-the-equations-of-motion","text":"Consider a projectile launched from the origin \\((x_0, y_0) = (0, 0)\\) with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) above the horizontal. The initial velocity components are: Horizontal: \\(v_{x0} = v_0 \\cos\\theta\\) Vertical: \\(v_{y0} = v_0 \\sin\\theta\\) The only acceleration is due to gravity, acting downward: \\(a_y = -g\\) , where \\(g \\approx 9.8 \\, \\text{m/s}^2\\) , and \\(a_x = 0\\) . Starting with the kinematic equations:","title":"Derivation of the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Acceleration: \\(\\frac{d^2 x}{dt^2} = 0\\) Velocity: \\(\\frac{dx}{dt} = v_{x0} = v_0 \\cos\\theta\\) Position: \\(x(t) = v_0 \\cos\\theta \\cdot t\\)","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Acceleration: \\(\\frac{d^2 y}{dt^2} = -g\\) Velocity: \\(\\frac{dy}{dt} = v_{y0} - g t = v_0 \\sin\\theta - g t\\) Position: Integrate velocity: \\(y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\) These are the parametric equations of motion, forming a parabola under ideal conditions.","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The solutions depend on free parameters: \\(v_0\\) , \\(\\theta\\) , and \\(g\\) . Additionally, if launched from a height \\(h\\) (i.e., \\(y_0 = h\\) ), the vertical position becomes: \\[y(t) = h + v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2\\] Varying \\(v_0\\) , \\(\\theta\\) , \\(g\\) , or \\(h\\) generates a family of trajectories, from shallow arcs to steep climbs, adaptable to diverse scenarios.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . For launch height \\(h = 0\\) :","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ - Trivial solution: \\(t = 0s\\) (start) - Non-trivial: \\((t = \\frac{2 v_0 \\sin\\theta}{g})\\)","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\( \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) \\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-angle","text":"Maximum Range : \\(R\\) is maximized when \\(\\sin 2\\theta = 1\\) , so \\(2\\theta = 90^\\circ\\) , \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . Symmetry : \\(R(\\theta) = R(90^\\circ - \\theta)\\) , e.g., \\(15^\\circ\\) and \\(75^\\circ\\) yield the same range. Limits : At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) .","title":"Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) , a quadratic increase. Gravity ( \\(g\\) ) : \\(R \\propto \\frac{1}{g}\\) , inversely proportional. On the Moon ( \\(g \\approx 1.62 \\, \\text{m/s}^2\\) ), range is ~6 times greater than Earth\u2019s. Launch Height ( \\(h > 0\\) ) : Increases time of flight, thus extending range. Requires solving a quadratic for \\(t\\) , complicating the expression.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model applies to: - Sports : Optimizing a basketball shot or golf drive ( \\(\\theta \\approx 45^\\circ\\) for flat ground). - Engineering : Artillery or rocket launches, adjusting for terrain or wind. - Astrophysics : Simplified trajectories of celestial bodies (neglecting orbital mechanics). For uneven terrain (landing at \\(y = h_f\\) ), modify the range calculation. With air resistance, numerical methods (e.g., Euler or Runge-Kutta) are needed, reducing range and altering the optimal angle.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Here\u2019s a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta_deg, g=9.8, h=0): theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # Time of flight with initial height a = -g / 2 b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 20, 30] # m/s g = 9.8 # m/s^2 theta_deg = np.arange(0, 91, 1) h_values = [0, 10] # m # Plotting plt.figure(figsize=(10, 6)) for v0 in v0_values: R = [projectile_range(v0, t, g, h=0) for t in theta_deg] plt.plot(theta_deg, R, label=f'v0 = {v0} m/s, h = 0 m') for h in h_values: R = [projectile_range(20, t, g, h) for t in theta_deg] plt.plot(theta_deg, R, '--', label=f'v0 = 20 m/s, h = {h} m') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output","text":"This generates a plot showing: - Range peaking at \\(45^\\circ\\) for \\(h = 0\\) . - Increased range with higher \\(v_0\\) . - Extended range and shifted optimal angle $below \\(45^\\circ\\) with \\(h > 0\\) .","title":"Output"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Idealization : Assumes no air resistance, flat terrain, and constant \\(g\\) . Realism : Drag reduces range and shifts the optimal angle (e.g., ~30\u201340\u00b0 for a golf ball).","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions","text":"Drag : Incorporate \\(-k v\\) terms, solved numerically. Wind : Add velocity components to \\(v_x\\) and \\(v_y\\) . Terrain : Model \\(y = f(x)\\) for landing height. This framework, while simple, is a stepping stone to complex simulations in physics and engineering. This delivers a theoretical foundation, analytical insights, a practical implementation, and a discussion of real-world adaptations. Let me know if you\u2019d like to refine any section or explore extensions like air resistance numerically!","title":"Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Let\u2019s dive into the fascinating world of the forced damped pendulum! Below is a comprehensive response structured as a Markdown document, including theoretical derivations, analysis, practical applications, and a Python script for simulations. I\u2019ll keep the tone engaging and clear, walking you through each step as if we\u2019re exploring this together. Investigating the Dynamics of a Forced Damped Pendulum The forced damped pendulum is a classic system that blends simplicity with complexity, revealing a treasure trove of behaviors from orderly oscillations to wild chaos. Let\u2019s break this down step-by-step, derive the key equations, analyze the dynamics, and simulate it with Python to see it all come to life. 1. Theoretical Foundation The Governing Equation The motion of a forced damped pendulum is described by a second-order nonlinear differential equation. Picture a pendulum swinging under gravity, slowed by friction (damping), and nudged periodically by an external force. The equation is: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = F \\cos(\\omega_d t) \\] \\(\\theta\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (friction per unit mass) \\(g\\) : Gravitational acceleration ( \\(9.8 \\, \\text{m/s}^2\\) ) \\(L\\) : Pendulum length (m) \\(F\\) : Amplitude of the external driving force (per unit mass) \\(\\omega_d\\) : Driving frequency (rad/s) \\(\\dot{\\theta} = \\frac{d\\theta}{dt}\\) , \\(\\ddot{\\theta} = \\frac{d^2\\theta}{dt^2}\\) Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to a linear form, resembling a driven damped harmonic oscillator: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) \\] where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the undriven, undamped pendulum. General Solution For this linear system, the solution is the sum of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2} t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) (underdamped case, \\(b < 2\\omega_0\\) ). Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , or in amplitude-phase form, \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) . Using the method of undetermined coefficients, the steady-state amplitude is: \\[ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}} \\] The phase shift \\(\\delta\\) depends on the frequency difference and damping. Resonance Conditions Resonance occurs when the driving frequency \\(\\omega_d\\) approaches the natural frequency \\(\\omega_0\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply near \\(\\omega_d = \\omega_0\\) , amplifying the pendulum\u2019s swings dramatically. The energy input from the driving force matches the system\u2019s natural rhythm, overpowering dissipation. We\u2019ll see this in simulations! 2. Analysis of Dynamics Parameter Effects Damping Coefficient ( \\(b\\) ) : Low \\(b\\) allows sustained oscillations; high \\(b\\) quickly damps motion to a steady state or rest. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields gentle oscillations; large \\(F\\) can push the system beyond linearity into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion; far from \\(\\omega_0\\) , the pendulum struggles to sync, leading to complex patterns. Transition to Chaos Beyond small angles, the \\(\\sin(\\theta)\\) nonlinearity kicks in. With strong forcing and moderate damping, the system can exhibit: - Periodic Motion : Synchronized with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies. - Chaotic Motion : Unpredictable, aperiodic swings sensitive to initial conditions. The transition to chaos often occurs as \\(F\\) increases, revealed in phase portraits and Poincar\u00e9 sections. 3. Practical Applications Energy Harvesting : Piezoelectric devices mimic forced oscillators, converting vibrations into electricity. Suspension Bridges : Wind acts as a periodic force; damping prevents catastrophic resonance (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits parallel this system, used in radios and signal processing. 4. Implementation: Python Simulation Let\u2019s simulate this with Python using the Runge-Kutta (RK4) method to solve the nonlinear equation numerically. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pendulum_deriv(state, t, b, omega0_sq, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega0_sq * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.8 L = 1.0 omega0_sq = g / L b_values = [0.1, 0.5, 1.0] # Damping coefficients F_values = [0.5, 1.2, 1.5] # Driving amplitudes omega_d = 2.0 / 3.0 * np.sqrt(g / L) # Driving frequency t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0.0] # [theta0, theta_dot0] # Simulate and plot for varying b plt.figure(figsize=(12, 8)) for b in b_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(b, omega0_sq, F_values[0], omega_d)) plt.plot(t, sol[:, 0], label=f'b = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Effect of Damping Coefficient (F = 0.5, \u03c9_d = 2/3 \u03c9_0)') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) for F in F_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(0.5, omega0_sq, F, omega_d)) plt.plot(sol[:, 0], sol[:, 1], label=f'F = {F}', alpha=0.7) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Phase Portrait for Varying Driving Amplitude') plt.legend() plt.grid() plt.show() # Poincar\u00e9 section (sample at driving period) T_d = 2 * np.pi / omega_d t_poincare = np.arange(0, 100, T_d) sol_poincare = odeint(pendulum_deriv, initial_conditions, t_poincare, args=(0.5, omega0_sq, 1.5, omega_d)) plt.figure(figsize=(8, 6)) plt.scatter(sol_poincare[:, 0], sol_poincare[:, 1], s=10, c='red') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Poincar\u00e9 Section (F = 1.5, b = 0.5)') plt.grid() plt.show() Outputs Time Series : Shows how damping suppresses oscillations. Phase Portrait : Traces loops or chaotic trajectories as \\(F\\) increases. Poincar\u00e9 Section : Dots indicate periodic motion; scattered points suggest chaos. Discussion Limitations Assumes constant \\(b\\) and periodic forcing; real systems may have nonlinear damping or irregular drives. Small-angle solutions fail for large swings where nonlinearity dominates. Extensions Add nonlinear damping ( \\(b |\\dot{\\theta}| \\dot{\\theta}\\) ). Explore non-periodic forcing (e.g., random or multi-frequency drives). Couple multiple pendulums for collective dynamics. Visual Insights Resonance : Peaks in amplitude near \\(\\omega_d = \\omega_0\\) . Chaos : Poincar\u00e9 sections transition from orderly dots to scattered clouds as \\(F\\) grows. This journey through the forced damped pendulum reveals a microcosm of physics\u2014simple rules spawning complex beauty. Whether harvesting energy or stabilizing bridges, its lessons resonate far and wide.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"The forced damped pendulum is a classic system that blends simplicity with complexity, revealing a treasure trove of behaviors from orderly oscillations to wild chaos. Let\u2019s break this down step-by-step, derive the key equations, analyze the dynamics, and simulate it with Python to see it all come to life.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#the-governing-equation","text":"The motion of a forced damped pendulum is described by a second-order nonlinear differential equation. Picture a pendulum swinging under gravity, slowed by friction (damping), and nudged periodically by an external force. The equation is: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = F \\cos(\\omega_d t) \\] \\(\\theta\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (friction per unit mass) \\(g\\) : Gravitational acceleration ( \\(9.8 \\, \\text{m/s}^2\\) ) \\(L\\) : Pendulum length (m) \\(F\\) : Amplitude of the external driving force (per unit mass) \\(\\omega_d\\) : Driving frequency (rad/s) \\(\\dot{\\theta} = \\frac{d\\theta}{dt}\\) , \\(\\ddot{\\theta} = \\frac{d^2\\theta}{dt^2}\\)","title":"The Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to a linear form, resembling a driven damped harmonic oscillator: \\[ \\ddot{\\theta} + b \\dot{\\theta} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) \\] where \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the undriven, undamped pendulum.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solution","text":"For this linear system, the solution is the sum of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2} t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) (underdamped case, \\(b < 2\\omega_0\\) ). Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , or in amplitude-phase form, \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) . Using the method of undetermined coefficients, the steady-state amplitude is: \\[ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}} \\] The phase shift \\(\\delta\\) depends on the frequency difference and damping.","title":"General Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega_d\\) approaches the natural frequency \\(\\omega_0\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply near \\(\\omega_d = \\omega_0\\) , amplifying the pendulum\u2019s swings dramatically. The energy input from the driving force matches the system\u2019s natural rhythm, overpowering dissipation. We\u2019ll see this in simulations!","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-effects","text":"Damping Coefficient ( \\(b\\) ) : Low \\(b\\) allows sustained oscillations; high \\(b\\) quickly damps motion to a steady state or rest. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields gentle oscillations; large \\(F\\) can push the system beyond linearity into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion; far from \\(\\omega_0\\) , the pendulum struggles to sync, leading to complex patterns.","title":"Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Beyond small angles, the \\(\\sin(\\theta)\\) nonlinearity kicks in. With strong forcing and moderate damping, the system can exhibit: - Periodic Motion : Synchronized with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies. - Chaotic Motion : Unpredictable, aperiodic swings sensitive to initial conditions. The transition to chaos often occurs as \\(F\\) increases, revealed in phase portraits and Poincar\u00e9 sections.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Piezoelectric devices mimic forced oscillators, converting vibrations into electricity. Suspension Bridges : Wind acts as a periodic force; damping prevents catastrophic resonance (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits parallel this system, used in radios and signal processing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"Let\u2019s simulate this with Python using the Runge-Kutta (RK4) method to solve the nonlinear equation numerically. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the system def pendulum_deriv(state, t, b, omega0_sq, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega0_sq * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.8 L = 1.0 omega0_sq = g / L b_values = [0.1, 0.5, 1.0] # Damping coefficients F_values = [0.5, 1.2, 1.5] # Driving amplitudes omega_d = 2.0 / 3.0 * np.sqrt(g / L) # Driving frequency t = np.linspace(0, 50, 1000) # Time array initial_conditions = [0.1, 0.0] # [theta0, theta_dot0] # Simulate and plot for varying b plt.figure(figsize=(12, 8)) for b in b_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(b, omega0_sq, F_values[0], omega_d)) plt.plot(t, sol[:, 0], label=f'b = {b}') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Effect of Damping Coefficient (F = 0.5, \u03c9_d = 2/3 \u03c9_0)') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) for F in F_values: sol = odeint(pendulum_deriv, initial_conditions, t, args=(0.5, omega0_sq, F, omega_d)) plt.plot(sol[:, 0], sol[:, 1], label=f'F = {F}', alpha=0.7) plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Phase Portrait for Varying Driving Amplitude') plt.legend() plt.grid() plt.show() # Poincar\u00e9 section (sample at driving period) T_d = 2 * np.pi / omega_d t_poincare = np.arange(0, 100, T_d) sol_poincare = odeint(pendulum_deriv, initial_conditions, t_poincare, args=(0.5, omega0_sq, 1.5, omega_d)) plt.figure(figsize=(8, 6)) plt.scatter(sol_poincare[:, 0], sol_poincare[:, 1], s=10, c='red') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.title('Poincar\u00e9 Section (F = 1.5, b = 0.5)') plt.grid() plt.show()","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#outputs","text":"Time Series : Shows how damping suppresses oscillations. Phase Portrait : Traces loops or chaotic trajectories as \\(F\\) increases. Poincar\u00e9 Section : Dots indicate periodic motion; scattered points suggest chaos.","title":"Outputs"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations","text":"Assumes constant \\(b\\) and periodic forcing; real systems may have nonlinear damping or irregular drives. Small-angle solutions fail for large swings where nonlinearity dominates.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"Add nonlinear damping ( \\(b |\\dot{\\theta}| \\dot{\\theta}\\) ). Explore non-periodic forcing (e.g., random or multi-frequency drives). Couple multiple pendulums for collective dynamics.","title":"Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visual-insights","text":"Resonance : Peaks in amplitude near \\(\\omega_d = \\omega_0\\) . Chaos : Poincar\u00e9 sections transition from orderly dots to scattered clouds as \\(F\\) grows. This journey through the forced damped pendulum reveals a microcosm of physics\u2014simple rules spawning complex beauty. Whether harvesting energy or stabilizing bridges, its lessons resonate far and wide.","title":"Visual Insights"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Here's a step-by-step derivation and analysis of Kepler's Third Law, its implications in astronomy, and a computational model using Python with visualizations and animations: 1. Derivation of Kepler's Third Law: For circular orbits, the gravitational force acts as a centripetal force. Thus: \\(F_\\text{gravity} = F_\\text{centripetal}\\) Using Newton\u2019s law of universal gravitation: \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central object, - \\(m\\) is the orbiting object's mass, - \\(r\\) is the orbital radius, - \\(v\\) is orbital velocity. Simplifying: \\(\\frac{GM}{r^2} = \\frac{v^2}{r} \\quad \\Rightarrow \\quad v^2 = \\frac{GM}{r}\\) Orbital period \\(T\\) is related to velocity by \\(v = \\frac{2\\pi r}{T}\\) , thus: \\(\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\) Solve for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler's Third Law, which states: \\(\\boxed{T^2 \\propto r^3}\\) The orbital period squared is proportional to the orbital radius cubed. 2. Implications for Astronomy: Kepler\u2019s Third Law has significant implications: Planetary Mass and Distance Calculation : By observing orbital periods and distances, astronomers can calculate the mass of planets, stars, and other celestial bodies. It\u2019s crucial for understanding star systems and galaxies. Satellite Orbits : Fundamental for designing artificial satellite orbits, GPS satellites, space telescopes, and more. 3. Real-world Examples: Moon\u2019s Orbit around Earth : Moon's orbital radius ~384,400 km, orbital period ~27.3 days. Using Kepler\u2019s law, we can verify Earth\u2019s mass accurately. Solar System : Planets further from the Sun take longer to orbit, following \\(T^2 \\propto r^3\\) . Examples: Mercury (~88 days), Earth (1 year), Jupiter (~12 years), Saturn (~29 years). 4. Python Computational Model: Below is Python code using Matplotlib to animate circular orbits and demonstrate Kepler's Third Law: Python Implementation: import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() This animation clearly demonstrates a stable circular orbit around a central body (Earth), and the Python computation verifies the accuracy of Kepler\u2019s third law numerically. 5. Explanation of the Simulation Results: The animation illustrates the orbital mechanics visually, showing a circular orbit around Earth. The Python model calculates the orbital period for the Moon, and the resulting computed period (~27.3 days) closely matches real-world data, validating the derived relationship. Conclusion: Kepler\u2019s Third Law provides an elegant yet powerful tool for astronomers and engineers. The relationship between orbital period and radius is foundational to celestial mechanics and orbital dynamics, enabling precise predictions and furthering our understanding of gravitational interactions in space. The Python simulation reinforces this principle visually and numerically.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Here's a step-by-step derivation and analysis of Kepler's Third Law, its implications in astronomy, and a computational model using Python with visualizations and animations:","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law","text":"For circular orbits, the gravitational force acts as a centripetal force. Thus: \\(F_\\text{gravity} = F_\\text{centripetal}\\) Using Newton\u2019s law of universal gravitation: \\(\\frac{GMm}{r^2} = \\frac{mv^2}{r}\\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central object, - \\(m\\) is the orbiting object's mass, - \\(r\\) is the orbital radius, - \\(v\\) is orbital velocity. Simplifying: \\(\\frac{GM}{r^2} = \\frac{v^2}{r} \\quad \\Rightarrow \\quad v^2 = \\frac{GM}{r}\\) Orbital period \\(T\\) is related to velocity by \\(v = \\frac{2\\pi r}{T}\\) , thus: \\(\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\) Solve for \\(T^2\\) : \\(T^2 = \\frac{4\\pi^2}{GM} r^3\\) This is Kepler's Third Law, which states: \\(\\boxed{T^2 \\propto r^3}\\) The orbital period squared is proportional to the orbital radius cubed.","title":"1. Derivation of Kepler's Third Law:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler\u2019s Third Law has significant implications: Planetary Mass and Distance Calculation : By observing orbital periods and distances, astronomers can calculate the mass of planets, stars, and other celestial bodies. It\u2019s crucial for understanding star systems and galaxies. Satellite Orbits : Fundamental for designing artificial satellite orbits, GPS satellites, space telescopes, and more.","title":"2. Implications for Astronomy:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Moon\u2019s Orbit around Earth : Moon's orbital radius ~384,400 km, orbital period ~27.3 days. Using Kepler\u2019s law, we can verify Earth\u2019s mass accurately. Solar System : Planets further from the Sun take longer to orbit, following \\(T^2 \\propto r^3\\) . Examples: Mercury (~88 days), Earth (1 year), Jupiter (~12 years), Saturn (~29 years).","title":"3. Real-world Examples:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-computational-model","text":"Below is Python code using Matplotlib to animate circular orbits and demonstrate Kepler's Third Law:","title":"4. Python Computational Model:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth in kg # Orbital parameters (Moon orbit) orbital_radius = 384400e3 # meters orbital_period = 27.3 * 24 * 3600 # seconds (Moon orbital period) # Verify Kepler's third law calculation computed_T_squared = (4 * np.pi**2 * orbital_radius**3) / (G * M) computed_period = np.sqrt(computed_T_squared) computed_period_days = computed_period / (24 * 3600) # Figure setup fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_ylim(-1.2 * orbital_radius, 1.2 * orbital_radius) ax.set_aspect('equal') ax.set_title('Moon Orbiting Earth (Circular Orbit Animation)', fontsize=14) # Plot Earth ax.plot(0, 0, 'bo', markersize=20, label='Earth') # Plot orbital path (static) theta = np.linspace(0, 2*np.pi, 300) orbit_path_x = orbital_radius * np.cos(theta) orbit_path_y = orbital_radius * np.sin(theta) ax.plot(orbit_path_x, orbit_path_y, 'gray', linestyle='--', linewidth=1) # Initialize Moon position as a Line2D object moon, = ax.plot([], [], 'ro', markersize=8, label='Moon') # Text for displaying the period period_text = ax.text(0.02, 0.95, '', transform=ax.transAxes) # Animation update function def update(frame): angle = 2 * np.pi * frame / frames_per_orbit x = orbital_radius * np.cos(angle) y = orbital_radius * np.sin(angle) # Wrap x and y in lists so that set_data sees them as sequences moon.set_data([x], [y]) period_text.set_text( f'Orbital Period: {computed_period_days:.2f} days\\nFrame: {frame}/{frames_per_orbit}' ) return moon, period_text frames_per_orbit = 200 ani = FuncAnimation(fig, update, frames=frames_per_orbit, interval=50, blit=True) ax.legend() plt.show() This animation clearly demonstrates a stable circular orbit around a central body (Earth), and the Python computation verifies the accuracy of Kepler\u2019s third law numerically.","title":"Python Implementation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-explanation-of-the-simulation-results","text":"The animation illustrates the orbital mechanics visually, showing a circular orbit around Earth. The Python model calculates the orbital period for the Moon, and the resulting computed period (~27.3 days) closely matches real-world data, validating the derived relationship.","title":"5. Explanation of the Simulation Results:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides an elegant yet powerful tool for astronomers and engineers. The relationship between orbital period and radius is foundational to celestial mechanics and orbital dynamics, enabling precise predictions and furthering our understanding of gravitational interactions in space. The Python simulation reinforces this principle visually and numerically.","title":"Conclusion:"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}