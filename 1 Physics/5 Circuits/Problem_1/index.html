<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#algorithm-description">Algorithm Description</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-representation-of-a-circuit">Graph Representation of a Circuit</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#series-connection-identification-and-reduction">Series Connection Identification and Reduction</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#parallel-connection-identification-and-reduction">Parallel Connection Identification and Reduction</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#iterative-reduction-of-complex-networks">Iterative Reduction of Complex Networks</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#pseudocode-for-equivalent-resistance-calculation">Pseudocode for Equivalent Resistance Calculation</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#python-implementation">Python Implementation</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testing-and-examples">Testing and Examples</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#example-1-basic-series-and-parallel">Example 1: Basic Series and Parallel</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#example-2-nested-series-parallel-configuration">Example 2: Nested Series-Parallel Configuration</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#example-3-complex-circuit-with-multiple-loops">Example 3: Complex Circuit with Multiple Loops</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#efficiency-and-analysis">Efficiency and Analysis</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<p>Great! I’ll provide both the algorithm description with detailed pseudocode and a full Python implementation for calculating equivalent resistance using graph theory.</p>
<p>I’ll ensure the implementation:</p>
<ul>
<li>Accepts a circuit graph as input.</li>
<li>Handles arbitrary resistor configurations, including nested series and parallel connections.</li>
<li>Outputs the final equivalent resistance.</li>
</ul>
<p>I'll also include:</p>
<ul>
<li>Three test cases (simple, nested, and complex graphs).</li>
<li>An explanation of how the algorithm processes each example.</li>
<li>A brief analysis of the algorithm’s efficiency and suggestions for improvement.</li>
</ul>
<p>I’ll get started and let you know as soon as the full solution is ready.</p>
<h1 id="calculating-equivalent-resistance-using-graph-theory">Calculating Equivalent Resistance Using Graph Theory</h1>
<h2 id="algorithm-description">Algorithm Description</h2>
<h3 id="graph-representation-of-a-circuit">Graph Representation of a Circuit</h3>
<p>We model the electrical circuit as a weighted <strong>graph</strong>: each <strong>node</strong> represents a junction (connection point), and each <strong>edge</strong> represents a resistor. The edge’s weight is the resistance value. This graph can be a <strong>multigraph</strong> – meaning there can be multiple edges between the same two nodes to represent <strong>parallel resistors</strong>. Two special nodes are designated as the <strong>terminal nodes</strong> (source and target) between which we want the equivalent resistance. By representing the circuit as a graph, series and parallel resistor combinations correspond to simple graph transformations.</p>
<h3 id="series-connection-identification-and-reduction">Series Connection Identification and Reduction</h3>
<p>A <strong>series</strong> connection occurs when a node (not a terminal) has exactly two connections – i.e. the node lies on a single path between two other nodes. In the graph, this means a node (say node X) has degree 2 (two distinct neighbors). The two resistors connected in series through that node can be <strong>collapsed</strong> into a single equivalent resistor. We remove the intermediate node X and connect its two neighbors directly with a new edge. The new edge’s resistance is the <strong>sum</strong> of the two series resistances. For example, if node X connects to A with 8 Ω and to B with 4 Ω in series, we remove X and replace those with a single 12 Ω resistor between A and B. This rule comes from the fact that resistances in series add up (R_total = R1 + R2 + …).</p>
<h3 id="parallel-connection-identification-and-reduction">Parallel Connection Identification and Reduction</h3>
<p>A <strong>parallel</strong> connection occurs when two nodes are directly connected by multiple resistor edges. In the graph, this appears as <strong>multiple edges between the same two nodes</strong>. These parallel resistors can be replaced by a single edge whose weight is the <strong>equivalent resistance</strong> of the parallel combination. The formula for two resistors in parallel is:
<span class="arithmatex">\(R_{\text{eq}} = \frac{1}{\frac{1}{R_1} + \frac{1}{R_2}}\)</span>
More generally, the reciprocal of the equivalent resistance is the sum of reciprocals of each parallel resistor:
$ \frac{1}{R_{\text{eq}}} = \frac{1}{R_1} + \frac{1}{R_2} + \cdots + \frac{1}{R_n} .$
Using this rule, we <strong>merge all parallel edges</strong> between two nodes into a single edge whose weight is <span class="arithmatex">\(R_{\text{eq}}\)</span>. (For instance, if two resistors of 8 Ω and 4 Ω are in parallel between the same nodes, their equivalent is <span class="arithmatex">\(\frac{1}{1/8 + 1/4} = \frac{1}{0.125 + 0.25} = \frac{1}{0.375} \approx 2.67\,\Omega\)</span>.) In practice, a quick method is: <em>“take the reciprocal of each branch’s resistance, sum them, and then take the reciprocal of that sum”</em>. If more than two resistors are in parallel, we apply the same formula by summing all their reciprocals.</p>
<h3 id="iterative-reduction-of-complex-networks">Iterative Reduction of Complex Networks</h3>
<p>For circuits with many components (possibly containing <strong>nested</strong> series and parallel combinations), we apply the above reductions <strong>iteratively</strong>. We repeatedly scan the graph for any simplifiable structure: combine any found parallel edges, and remove any degree-2 node by series combination. Each reduction simplifies the graph (reducing the total number of edges or nodes). These steps are repeated until the entire network has been reduced to a single equivalent resistor between the two terminal nodes. In other words:</p>
<ul>
<li><strong>Continue simplifying</strong> the graph by series or parallel reductions <em>until only two nodes remain connected by one edge</em>. That edge’s weight is the equivalent resistance between the terminals.</li>
<li>This process naturally handles nested combinations: simplifying one part of the network can reveal new series or parallel relationships in the reduced graph, which we then simplify next.</li>
</ul>
<p>If no series or parallel simplifications remain but more than one resistor still connects the terminals, the circuit may not be a simple series-parallel network (it might have a bridge or mesh that requires more advanced transforms like Δ–Y). In such cases, more general graph-theoretic methods (like solving Kirchhoff’s equations or using matrix operations) can be used, but for this algorithm we assume a series-parallel reducible network.</p>
<h3 id="pseudocode-for-equivalent-resistance-calculation">Pseudocode for Equivalent Resistance Calculation</h3>
<p>Below is pseudocode outlining the algorithm to compute equivalent resistance between two terminal nodes <code>S</code> and <code>T</code> using graph reductions:</p>
<pre><code class="language-pseudo">function equivalent_resistance(Graph G, node S, node T):
    mark S and T as terminal_nodes
    # Repeat until no more reductions can be applied
    loop:
        # 1. Parallel reduction: find any parallel edges
        for each pair of nodes (u, v) in G:
            if there are multiple edges between u and v:
                # combine parallel resistors between u and v
                compute R_eq = parallel_equivalent(all edges between u and v)
                remove all edges between u and v from G
                add a single edge (u, v) with weight = R_eq
                continue loop  (start over after a reduction)
        # 2. Series reduction: find any series node
        for each node n in G (excluding terminals S and T):
            if degree(n) == 2 (n has exactly two neighbors, say u and v):
                # combine series resistors through n
                let the two edges be (u–n) with R1 and (n–v) with R2
                R_eq = R1 + R2
                remove node n and its edges from G
                add a new edge (u, v) with weight = R_eq
                continue loop
        # If no series or parallel reduction was performed in this loop, we are done
        break loop
    # At this point, the graph should have a single edge between S and T
    return weight of edge (S, T) as the equivalent resistance
</code></pre>
<p>In the pseudocode above, <code>parallel_equivalent(...)</code> denotes the calculation <span class="arithmatex">\(R_{\text{eq}}\)</span> for parallel resistors (using the reciprocal-sum formula). The algorithm gives preference to parallel reductions first (this order can be swapped; ultimately all reducible parts will be handled). After no further reductions are possible, the remaining edge weight between the terminals is returned as the equivalent resistance. (If the network wasn’t fully reducible by series/parallel, additional methods would be needed, but in our context we assume it is reducible to one resistor.)</p>
<h2 id="python-implementation">Python Implementation</h2>
<p>We can implement this algorithm in Python. We will use <strong>NetworkX</strong> to manage the graph structure (for convenience in handling nodes and edges). A NetworkX <code>MultiGraph</code> is suitable since it allows multiple edges between the same nodes (to represent parallel resistors). The implementation will iteratively perform the series and parallel reductions as described:</p>
<pre><code class="language-python">import networkx as nx

def equivalent_resistance(G, source, target):
    """Compute the equivalent resistance between two nodes in a resistor network.
    G is a NetworkX graph (preferably nx.MultiGraph) with 'weight' attributes for resistances."""
    # Work on a copy to avoid modifying the original graph
    G = G.copy()
    # Ensure we have a MultiGraph to handle parallel edges
    if not isinstance(G, nx.MultiGraph):
        G = nx.MultiGraph(G)  # convert Graph to MultiGraph (copies edges)
    # Helper function to combine all parallel edges between u and v
    def combine_parallel(u, v):
        weights = [data['weight'] for key, data in G[u][v].items()]
        # Calculate equivalent resistance of resistors in parallel
        inv_sum = 0.0
        for w in weights:
            if w == 0:          # a short (0Ω) makes total 0Ω
                inv_sum = float('inf')
                break
            inv_sum += 1.0 / w
        R_eq = 0.0 if inv_sum == float('inf') else 1.0 / inv_sum
        # Remove old edges and add a single new edge
        G.remove_edges_from([(u, v, k) for k in list(G[u][v].keys())])
        G.add_edge(u, v, weight=R_eq)
    # Iteratively reduce the graph
    while True:
        # 1. Check for any parallel edges in the graph
        parallel_found = False
        for u, v in list(G.edges()):  # iterate over edges
            if u == v:
                continue  # ignore self-loops if any
            # In MultiGraph, multiple edges (parallel) will appear multiple times in edges()
            # We detect parallel by checking adjacency:
            if len(G[u][v]) &gt; 1:      # more than one edge between u and v
                combine_parallel(u, v)
                parallel_found = True
                break  # break out to restart loop (graph changed)
        if parallel_found:
            continue
        # 2. Check for any series node (degree 2, not a terminal)
        series_found = False
        for n in list(G.nodes()):
            if n in (source, target):
                continue  # do not remove terminal nodes
            # Degree in MultiGraph counts multiple edges separately. We want exactly 2 edges total.
            if G.degree(n) == 2 and len(G[n]) == 2:
                # Node n has exactly two neighbors (series connection)
                neighbors = list(G[n])  # two distinct neighbors
                u, v = neighbors[0], neighbors[1]
                # Sum the resistance of edges n-u and n-v (there could be single edges due to no parallel at n)
                total_res = sum(data['weight'] for data in G[n][u].values()) + \
                            sum(data['weight'] for data in G[n][v].values())
                # Remove node n and its two edges
                G.remove_node(n)
                # Add a direct edge between u and v with the combined resistance
                G.add_edge(u, v, weight=total_res)
                series_found = True
                break  # break to restart since graph changed
        if series_found:
            continue
        # If neither parallel nor series reduction was done, exit loop
        break
    # After reduction, the graph should have an edge between source and target
    if source in G and target in G and target in G[source]:
        # Return the weight of the remaining edge (source-target)
        # (Handle MultiGraph case with potentially one edge left)
        edge_data = G.get_edge_data(source, target)
        if edge_data:
            # edge_data is a dict of edges (for MultiGraph) or attributes (for Graph)
            if 'weight' in edge_data:
                return edge_data['weight']              # Graph case
            else:
                # MultiGraph case: take weight of the first (only) edge
                key = next(iter(edge_data.keys()))
                return edge_data[key]['weight']
    # If we reach here, no direct edge (fully reducible) found – possibly not a series-parallel network.
    # As a fallback, use networkx to compute resistance distance via linear algebra (if connected)
    try:
        return nx.resistance_distance(G, source, target, weight='weight')
    except Exception:
        return None  # network might be disconnected or other issue
</code></pre>
<p>This function performs exactly the logic described in the pseudocode. It first ensures the graph is a MultiGraph (so that parallel edges are maintained separately). Then it enters a loop where it searches for parallel edges and series nodes, simplifying one at a time and restarting the search whenever a reduction is made (because each reduction can create new opportunities for further simplification).</p>
<p>A few implementation details to note:</p>
<ul>
<li>We used <code>G.degree(n)</code> and <code>len(G[n])</code> to identify series nodes. <code>G.degree(n)</code> gives the count of <strong>edges</strong> incident on <code>n</code> (counting multiple edges separately), while <code>len(G[n])</code> gives the number of <strong>distinct neighbors</strong> of <code>n</code>. For a node to be a series candidate, it should have exactly 2 distinct neighbors and exactly 2 total edge connections (meaning one edge to each neighbor). This ensures we only collapse nodes that truly lie on a single path between two other nodes.</li>
<li>When combining parallel edges, we remove <em>all</em> edges between the two nodes and replace them with one edge with the equivalent resistance (calculated via the reciprocal sum of weights). We take care that if a 0 Ω resistor (a direct short) is present, the equivalent resistance is 0 (since a short in parallel dominates).</li>
<li>We always avoid removing the specified terminal nodes (<code>source</code> and <code>target</code>), even if they have degree 2, because those define the endpoints between which we measure the equivalent resistance. Only non-terminal degree-2 nodes are safe to eliminate.</li>
<li>If the network cannot be fully reduced by series/parallel (e.g. a bridge network), the function attempts a <strong>fallback</strong>: using <code>nx.resistance_distance</code> (which computes the effective resistance via linear algebra on the graph Laplacian). This requires NetworkX 3.x and SciPy; if that fails or the graph isn’t connected, the function returns <code>None</code> as an indication that it couldn’t compute a result through reduction alone.</li>
</ul>
<h2 id="testing-and-examples">Testing and Examples</h2>
<p>We will test the algorithm on several circuits:</p>
<h3 id="example-1-basic-series-and-parallel">Example 1: Basic Series and Parallel</h3>
<p><strong>Circuit:</strong> A simple triangle-shaped network with resistors <span class="arithmatex">\(R_1\)</span>, <span class="arithmatex">\(R_2\)</span> in series and <span class="arithmatex">\(R_3\)</span> in parallel with them. Node <strong>A</strong> is connected to <strong>B</strong> through <span class="arithmatex">\(R_1 = 8\)</span>\Omega, <strong>B</strong> to <strong>C</strong> through <span class="arithmatex">\(R_2 = 4\)</span>\Omega. Additionally, <strong>A</strong> is directly connected to <strong>C</strong> through <span class="arithmatex">\(R_3 = 6\)</span>\Omega (parallel to the path A–B–C). We want the equivalent resistance between A and C.</p>
<ul>
<li><strong>Graph model:</strong> Nodes = {A, B, C}. Edges = {(A–B: 8Ω), (B–C: 4Ω), (A–C: 6Ω)}.</li>
</ul>
<p>Using our function on this graph:</p>
<pre><code class="language-python">G = nx.MultiGraph()
G.add_edge('A', 'B', weight=8.0)
G.add_edge('B', 'C', weight=4.0)
G.add_edge('A', 'C', weight=6.0)
print(equivalent_resistance(G, 'A', 'C'))
</code></pre>
<p><strong>Output:</strong> <code>4.0</code> (Ω)</p>
<p><strong>Step-by-step simplification:</strong></p>
<ol>
<li>Node B has degree 2 (neighbors A and C) and is not a terminal, so resistors A–B and B–C are in series. We combine them: <span class="arithmatex">\(8Ω + 4Ω = 12Ω\)</span>. The graph now has an edge A–C of 12Ω (from this series combination) and the original parallel edge A–C of 6Ω.</li>
<li>Now between A and C there are two parallel resistors (12Ω and 6Ω). We combine these parallel edges using the formula <span class="arithmatex">\(1/R_{\text{eq}} = 1/12 + 1/6\)</span>. This gives <span class="arithmatex">\(1/R_{\text{eq}} = 0.0833 + 0.1667 = 0.25\)</span>, so <span class="arithmatex">\(R_{\text{eq}} = 4Ω\)</span>. We replace the two A–C edges with a single 4Ω edge.</li>
<li>Only nodes A and C remain, connected by one edge of 4Ω. This is the equivalent resistance <span class="arithmatex">\(R_{AC} = 4\)</span>\Omega.</li>
</ol>
<h3 id="example-2-nested-series-parallel-configuration">Example 2: Nested Series-Parallel Configuration</h3>
<p><strong>Circuit:</strong> A network with two distinct paths (branches) between the terminals, each branch containing a series pair of resistors. This creates a <strong>parallel</strong> combination of two series sub-networks. Specifically, consider nodes <strong>A</strong> and <strong>C</strong> as terminals, with two branches between them:</p>
<ul>
<li><strong>Branch 1:</strong> A–B–C, with <span class="arithmatex">\(R_{AB} = 10\)</span>\Omega and <span class="arithmatex">\(R_{BC} = 20\)</span>\Omega in series.</li>
<li><strong>Branch 2:</strong> A–D–C, with <span class="arithmatex">\(R_{AD} = 15\)</span>\Omega and <span class="arithmatex">\(R_{DC} = 5\)</span>\Omega in series.</li>
</ul>
<p>This circuit has <em>two loops</em> and resistors in both series and parallel. The goal is the equivalent resistance between A and C.</p>
<ul>
<li><strong>Graph model:</strong> Nodes = {A, B, C, D}. Edges = {(A–B: 10Ω), (B–C: 20Ω), (A–D: 15Ω), (D–C: 5Ω)}.</li>
</ul>
<p>Running the function:</p>
<pre><code class="language-python">G = nx.MultiGraph()
G.add_edge('A','B', weight=10.0)
G.add_edge('B','C', weight=20.0)
G.add_edge('A','D', weight=15.0)
G.add_edge('D','C', weight=5.0)
print(equivalent_resistance(G, 'A', 'C'))
</code></pre>
<p><strong>Output:</strong> <code>12.0</code> (Ω) (approximately, due to floating-point rounding)</p>
<p><strong>Step-by-step simplification:</strong></p>
<ol>
<li>Node B has degree 2 (neighbors A and C) and is not a terminal. Combine A–B and B–C in series: <span class="arithmatex">\(10 + 20 = 30\)</span>\Omega. Remove B, add an edge A–C of 30Ω.</li>
<li>Node D has degree 2 (neighbors A and C) and is not a terminal. Combine A–D and D–C in series: <span class="arithmatex">\(15 + 5 = 20\)</span>\Omega. Remove D, add another edge A–C of 20Ω.</li>
<li>Now the only two nodes left are A and C, but they have two parallel connections: one 30Ω and one 20Ω. We combine these in parallel:
   <span class="arithmatex">\(\frac{1}{R_{\text{eq}}} = \frac{1}{30} + \frac{1}{20} = 0.0333 + 0.05 = 0.08333...\)</span>
   so <span class="arithmatex">\(R_{\text{eq}} \approx 12.0\,\Omega\)</span>. We replace the two edges with a single 12Ω edge.</li>
</ol>
<p>The final answer is <span class="arithmatex">\(R_{AC} = 12\,\Omega\)</span>. (This result can be verified: branch1 had 30Ω, branch2 had 20Ω, their parallel combination is indeed $ (30 \parallel 20) = 12Ω$.)</p>
<h3 id="example-3-complex-circuit-with-multiple-loops">Example 3: Complex Circuit with Multiple Loops</h3>
<p><strong>Circuit:</strong> A more complex network with <strong>three parallel branches</strong> between the terminals, where two branches themselves contain series resistors. This will test multiple nested reductions and parallel combinations at once. Let terminals be <strong>A</strong> and <strong>C</strong>, and define three branches:</p>
<ul>
<li><strong>Branch 1:</strong> A–B–C with <span class="arithmatex">\(R_{AB} = 2\)</span>\Omega, <span class="arithmatex">\(R_{BC} = 4\)</span>\Omega (series total 6Ω).</li>
<li><strong>Branch 2:</strong> A–D–C with <span class="arithmatex">\(R_{AD} = 3\)</span>\Omega, <span class="arithmatex">\(R_{DC} = 3\)</span>\Omega (series total 6Ω).</li>
<li><strong>Branch 3:</strong> A–C direct with <span class="arithmatex">\(R_{AC} = 6\)</span>\Omega.</li>
</ul>
<p>This network has multiple loops (cycles). We compute the equivalent resistance between A and C.</p>
<ul>
<li><strong>Graph model:</strong> Nodes = {A, B, C, D}. Edges = {(A–B: 2Ω), (B–C: 4Ω), (A–D: 3Ω), (D–C: 3Ω), (A–C: 6Ω)}.</li>
</ul>
<p>Using the function:</p>
<pre><code class="language-python">G = nx.MultiGraph()
G.add_edge('A','B', weight=2.0)
G.add_edge('B','C', weight=4.0)
G.add_edge('A','D', weight=3.0)
G.add_edge('D','C', weight=3.0)
G.add_edge('A','C', weight=6.0)
print(equivalent_resistance(G, 'A', 'C'))
</code></pre>
<p><strong>Output:</strong> <code>2.0</code> (Ω)</p>
<p><strong>Step-by-step simplification:</strong></p>
<ol>
<li>Node B (degree 2) is not a terminal. Combine A–B and B–C: <span class="arithmatex">\(2 + 4 = 6\)</span>\Omega. Remove B, add edge A–C of 6Ω.</li>
<li>Node D (degree 2) is not a terminal. Combine A–D and D–C: <span class="arithmatex">\(3 + 3 = 6\)</span>\Omega. Remove D, add another edge A–C of 6Ω.</li>
<li>Now nodes A and C have three parallel edges between them (three resistors of 6Ω each: one from branch1, one from branch2, and the original 6Ω branch3). Combine all three in parallel:
   <span class="arithmatex">\(\frac{1}{R_{\text{eq}}} = \frac{1}{6} + \frac{1}{6} + \frac{1}{6} = 0.5,\)</span>
   so <span class="arithmatex">\(R_{\text{eq}} = \frac{1}{0.5} = 2\,\Omega\)</span>. We replace the three edges with one edge of 2Ω.</li>
</ol>
<p>The final equivalent resistance is <span class="arithmatex">\(R_{AC} = 2\,\Omega\)</span>. This example shows how multiple series reductions can create several parallel edges that are then combined in one step. The algorithm handled the nested series-parallel combinations in stages until only one resistor remained.</p>
<p><em>(If we attempted to simplify this circuit manually from scratch: Branch1 and Branch2 each simplify to 6Ω; then we have three 6Ω resistors in parallel between A and C. Two in parallel would give 3Ω, and 3Ω in parallel with the third 6Ω gives 2Ω, confirming the result.)</em></p>
<h2 id="efficiency-and-analysis">Efficiency and Analysis</h2>
<p><strong>Computational Complexity:</strong> The above algorithm iteratively scans for series or parallel patterns and reduces them. In the worst case for an <em>N</em>-node, <em>E</em>-edge series-parallel graph, each reduction removes at least one node or edge. Suppose the network has <span class="arithmatex">\(N\)</span> nodes and roughly <span class="arithmatex">\(E\)</span> edges. Checking for parallel edges requires scanning the adjacency lists (O(E) in the worst case). Checking for series nodes requires scanning nodes (O(N)). Each reduction reduces the size of the graph (one less node or edge), and we loop until no more reductions. In the worst case (e.g., a long series chain of nodes), we might perform O(N) reduction steps, each step scanning O(N + E). This yields roughly <strong>O((N+E) * N)</strong> time complexity in the worst case, which is on the order of <span class="arithmatex">\(O(N^2)\)</span> for a simple series chain (since E ≈ N in a simple series) or up to <span class="arithmatex">\(O(N * E)\)</span> in denser graphs. However, <strong>series-parallel networks</strong> tend not to be extremely dense (they are often planar and have at most linear number of edges in N for simple series-parallel circuits). In practice, the algorithm is efficient for reasonably sized circuits.</p>
<p>We can optimize the algorithm by avoiding full rescans after each reduction. For example, we could maintain a list (or queue) of candidate nodes for series reduction (initially all nodes with degree 2) and update it dynamically as the graph changes, rather than scanning all nodes each time. Similarly, parallel edges can be tracked via adjacency checks when edges are added or removed. These optimizations would ensure we only inspect parts of the graph that are affected by each change, approaching linear complexity in total operations.</p>
<p><strong>Handling Arbitrary Networks:</strong> The given algorithm assumes the circuit can be simplified using series and parallel reductions alone (a <em>series-parallel</em> network). Some circuits with complex meshes (for example, a <strong>Wheatstone bridge</strong> or other non-series-parallel configurations) cannot be reduced by series/parallel simplifications alone. In those cases, more advanced techniques are required, such as the <strong>Δ–Y (Delta–Wye) transform</strong> to convert a triangle of resistors into an equivalent star network (or vice versa), or purely graph-theoretic methods using linear algebra. From a graph theory perspective, the <em>effective resistance</em> between two nodes in a general resistor network can be found by solving a system of linear equations (Kirchhoff’s laws) or by computing the pseudoinverse of the Laplacian matrix of the graph. This is essentially what SPICE and circuit simulators do: they set up matrices and invert them to find currents and voltages. That general approach has a complexity of about <span class="arithmatex">\(O(N^3)\)</span> for matrix inversion (or better with sparse matrix methods and optimizations), but it will work for any network configuration.</p>
<p><strong>Summary:</strong> For circuits that <strong>are</strong> series-parallel, the described iterative reduction algorithm is straightforward and efficient, simplifying the network step by step. Its complexity is manageable for typical circuits and can be improved with minor optimizations. For more complex arbitrary resistor networks, the algorithm can be extended with additional transforms (like Δ–Y) or replaced by a full matrix-solving approach to handle cases that defy simple series/parallel reduction. In all cases, modeling the circuit as a graph and systematically reducing it (either by graph transformations or by linear algebra) provides a clear path to finding the <strong>equivalent resistance</strong> between any two nodes.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
